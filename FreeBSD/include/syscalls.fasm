;  $FreeBSD: src/sys/kern/syscalls.master,v 1.259.2.4.2.1 2010/12/21 17:09:25 kensmith Exp $
;	from: @(#)syscalls.master	8.2 (Berkeley) 1/13/94
;
; System call name/number master file.
; Processed to created init_sysent.c, syscalls.c and syscall.h.

; Columns: number audit type name alt{name,tag,rtyp}/comments
;	number	system call number, must be in order
;	audit	the audit event associated with the system call
;		A value of AUE_NULL means no auditing, but it also means that
;		there is no audit event for the call at this time. For the
;		case where the event exists, but we don't want auditing, the
;		event should be #defined to AUE_NULL in audit_kevents.h.
;	type	one of STD, OBSOL, UNIMPL, COMPAT, COMPAT4, COMPAT6,
;		COMPAT7, LIBCOMPAT, NODEF, NOARGS, NOPROTO, NOSTD
;		The COMPAT* options may be combined with one or more NO*
;		options separated by '|' with no spaces (e.g. COMPAT|NOARGS)
;	name	psuedo-prototype of syscall routine
;		If one of the following alts is different, then all appear:
;	altname	name of system call if different
;	alttag	name of args struct tag if different from [o]`name'"_args"
;	altrtyp	return type if not int (bogus - syscalls always return int)
;		for UNIMPL/OBSOL, name continues with comments

; types:
;	STD	always included
;	COMPAT	included on COMPAT #ifdef
;	COMPAT4	included on COMPAT4 #ifdef (FreeBSD 4 compat)
;	COMPAT6	included on COMPAT6 #ifdef (FreeBSD 6 compat)
;	COMPAT7	included on COMPAT7 #ifdef (FreeBSD 7 compat)
;	LIBCOMPAT included on COMPAT #ifdef, and placed in syscall.h
;	OBSOL	obsolete, not included in system, only specifies name
;	UNIMPL	not implemented, placeholder only
;	NOSTD	implemented but as a lkm that can be statically
;		compiled in; sysent entry will be filled with lkmressys
;		so the SYSCALL_MODULE macro works
;	NOARGS	same as STD except do not create structure in sys/sysproto.h
;	NODEF	same as STD except only have the entry in the syscall table
;		added.  Meaning - do not create structure or function
;		prototype in sys/sysproto.h
;	NOPROTO	same as STD except do not create structure or
;		function prototype in sys/sysproto.h.  Does add a
;		definition to syscall.h besides adding a sysent.

;
; Please copy any additions and changes to the following compatability tables:
; sys/compat/freebsd32/syscalls.master

; #ifdef's, etc. may be included, and are copied to the output files.

; #include <sys/param.h>
; #include <sys/sysent.h>
; #include <sys/sysproto.h>

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

	;SYS_NOSYS                     = 0 ; int nosys(void);
	SYS_EXIT                       = 1 ; void sys_exit(int rval);
	SYS_FORK                       = 2 ; int fork(void);
	SYS_READ                       = 3 ; ssize_t read(int fd, void *buf, size_t nbyte);
	SYS_WRITE                      = 4 ; ssize_t write(int fd, const void *buf, size_t nbyte);
	SYS_OPEN                       = 5 ; int open(char *path, int flags, int mode);
; XXX should be		{ int open(const char *path, int flags, ...); }
; but we're not ready for `const' or varargs.
; XXX man page says `mode_t mode'.
	SYS_CLOSE                      = 6 ; int close(int fd);
	SYS_WAIT4                      = 7 ; int wait4(int pid, int *status, int options, struct rusage *rusage);
if defined COMPAT
	SYS_CREAT                      = 8 ; int creat(char *path, int mode);
end if
	SYS_LINK                       = 9 ; int link(char *path, char *link);
	SYS_UNLINK                     = 10 ; int unlink(char *path);
	;SYS_EXECV                     = 11 ; OBSOL
	SYS_CHDIR                      = 12 ; int chdir(char *path);
	SYS_FCHDIR                     = 13 ; int fchdir(int fd);
	SYS_MKNOD                      = 14 ; int mknod(char *path, int mode, int dev);
	SYS_CHMOD                      = 15 ; int chmod(char *path, int mode);
	SYS_CHOWN                      = 16 ; int chown(char *path, int uid, int gid);
	SYS_OBREAK                     = 17 ; int obreak(char *nsize);
if defined COMPAT4
	SYS_GETFSSTAT                  = 18 ; int getfsstat(struct ostatfs *buf, long bufsize, int flags);
end if
if defined COMPAT
	SYS_LSEEK                      = 19 ; long lseek(int fd, long offset, int whence);
end if
	SYS_GETPID                     = 20 ; pid_t getpid(void);
	SYS_MOUNT                      = 21 ; int mount(char *type, char *path, int flags, caddr_t data);
; XXX `path' should have type `const char *' but we're not ready for that.
	SYS_UNMOUNT                    = 22 ; int unmount(char *path, int flags);
	SYS_SETUID                     = 23 ; int setuid(uid_t uid);
	SYS_GETUID                     = 24 ; uid_t getuid(void);
	SYS_GETEUID                    = 25 ; uid_t geteuid(void);
	SYS_PTRACE                     = 26 ; int ptrace(int req, pid_t pid, caddr_t addr, int data);
	SYS_RECVMSG                    = 27 ; int recvmsg(int s, struct msghdr *msg, int flags);
	SYS_SENDMSG                    = 28 ; int sendmsg(int s, struct msghdr *msg, int flags);
	SYS_RECVFROM                   = 29 ; int recvfrom(int s, caddr_t buf, size_t len, int flags, struct sockaddr * __restrict from, __socklen_t * __restrict fromlenaddr);
	SYS_ACCEPT                     = 30 ; int accept(int s, struct sockaddr * __restrict name, __socklen_t * __restrict anamelen);
	SYS_GETPEERNAME                = 31 ; int getpeername(int fdes, struct sockaddr * __restrict asa, __socklen_t * __restrict alen);
	SYS_GETSOCKNAME                = 32 ; int getsockname(int fdes, struct sockaddr * __restrict asa, __socklen_t * __restrict alen);
	SYS_ACCESS                     = 33 ; int access(char *path, int flags);
	SYS_CHFLAGS                    = 34 ; int chflags(char *path, int flags);
	SYS_FCHFLAGS                   = 35 ; int fchflags(int fd, int flags);
	SYS_SYNC                       = 36 ; int sync(void);
	SYS_KILL                       = 37 ; int kill(int pid, int signum);
if defined COMPAT
	SYS_STAT                       = 38 ; int stat(char *path, struct ostat *ub);
end if
	SYS_GETPPID                    = 39 ; pid_t getppid(void);
if defined COMPAT
	SYS_LSTAT                      = 40 ; int lstat(char *path, struct ostat *ub);
end if
	SYS_DUP                        = 41 ; int dup(u_int fd);
	SYS_PIPE                       = 42 ; int pipe(void);
	SYS_GETEGID                    = 43 ; gid_t getegid(void);
	SYS_PROFIL                     = 44 ; int profil(caddr_t samples, size_t size, size_t offset, u_int scale);
	SYS_KTRACE                     = 45 ; int ktrace(const char *fname, int ops, int facs, int pid);
if defined COMPAT
	SYS_SIGACTION                  = 46 ; int sigaction(int signum, struct osigaction *nsa, struct osigaction *osa);
end if
	SYS_GETGID                     = 47 ; gid_t getgid(void);
if defined COMPAT
	SYS_SIGPROCMASK                = 48 ; int sigprocmask(int how, osigset_t mask);
; XXX note nonstandard (bogus) calling convention - the libc stub passes
; us the mask, not a pointer to it, and we return the old mask as the
; (int) return value.
end if
	SYS_GETLOGIN                   = 49 ; int getlogin(char *namebuf, u_int namelen);
	SYS_SETLOGIN                   = 50 ; int setlogin(char *namebuf);
	SYS_ACCT                       = 51 ; int acct(char *path);
if defined COMPAT
	SYS_SIGPENDING                 = 52 ; int sigpending(void);
end if
	SYS_SIGALTSTACK                = 53 ; int sigaltstack(stack_t *ss, stack_t *oss);
	SYS_IOCTL                      = 54 ; int ioctl(int fd, u_long com, caddr_t data);
	SYS_REBOOT                     = 55 ; int reboot(int opt);
	SYS_REVOKE                     = 56 ; int revoke(char *path);
	SYS_SYMLINK                    = 57 ; int symlink(char *path, char *link);
	SYS_READLINK                   = 58 ; ssize_t readlink(char *path, char *buf, size_t count);
	SYS_EXECVE                     = 59 ; int execve(char *fname, char **argv, char **envv);
	SYS_UMASK                      = 60 ; int umask(int newmask);
	SYS_CHROOT                     = 61 ; int chroot(char *path);
if defined COMPAT
	SYS_FSTAT                      = 62 ; int fstat(int fd, struct ostat *sb);
	SYS_GETKERNINFO                = 63 ; int getkerninfo(int op, char *where, size_t *size, int arg);
	SYS_GETPAGESIZE                = 64 ; int getpagesize(void);
end if
	SYS_MSYNC                      = 65 ; int msync(void *addr, size_t len, int flags);
	SYS_VFORK                      = 66 ; int vfork(void);
	;SYS_VREAD                     = 67 ; OBSOL
	;SYS_VWRITE                    = 68 ; OBSOL
	SYS_SBRK                       = 69 ; int sbrk(int incr);
	SYS_SSTK                       = 70 ; int sstk(int incr);
if defined COMPAT
	SYS_MMAP                       = 71 ; int mmap(void *addr, int len, int prot, int flags, int fd, long pos);
end if
	SYS_OVADVISE                   = 72 ; int ovadvise(int anom);
	SYS_MUNMAP                     = 73 ; int munmap(void *addr, size_t len);
	SYS_MPROTECT                   = 74 ; int mprotect(const void *addr, size_t len, int prot);
	SYS_MADVISE                    = 75 ; int madvise(void *addr, size_t len, int behav);
	;SYS_VHANGUP                   = 76 ; OBSOL
	;SYS_VLIMIT                    = 77 ; OBSOL
	SYS_MINCORE                    = 78 ; int mincore(const void *addr, size_t len, char *vec);
	SYS_GETGROUPS                  = 79 ; int getgroups(u_int gidsetsize, gid_t *gidset);
	SYS_SETGROUPS                  = 80 ; int setgroups(u_int gidsetsize, gid_t *gidset);
	SYS_GETPGRP                    = 81 ; int getpgrp(void);
	SYS_SETPGID                    = 82 ; int setpgid(int pid, int pgid);
	SYS_SETITIMER                  = 83 ; int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv);
if defined COMPAT
	SYS_WAIT                       = 84 ; int wait(void);
end if
	SYS_SWAPON                     = 85 ; int swapon(char *name);
	SYS_GETITIMER                  = 86 ; int getitimer(u_int which, struct itimerval *itv);
if defined COMPAT
	SYS_GETHOSTNAME                = 87 ; int gethostname(char *hostname, u_int len);
	SYS_SETHOSTNAME                = 88 ; int sethostname(char *hostname, u_int len);
end if
	SYS_GETDTABLESIZE              = 89 ; int getdtablesize(void);
	SYS_DUP2                       = 90 ; int dup2(u_int from, u_int to);
	;SYS_GETDOPT                   = 91 ; UNIMPL
	SYS_FCNTL                      = 92 ; int fcntl(int fd, int cmd, long arg);
; XXX should be	{ int fcntl(int fd, int cmd, ...); }
; but we're not ready for varargs.
	SYS_SELECT                     = 93 ; int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv);
	;SYS_SETDOPT                   = 94 ; UNIMPL
	SYS_FSYNC                      = 95 ; int fsync(int fd);
	SYS_SETPRIORITY                = 96 ; int setpriority(int which, int who, int prio);
	SYS_SOCKET                     = 97 ; int socket(int domain, int type, int protocol);
	SYS_CONNECT                    = 98 ; int connect(int s, caddr_t name, int namelen);
if defined COMPAT
	SYS_ACCEPT                     = 99 ; int accept(int s, caddr_t name, int *anamelen);
end if
	SYS_GETPRIORITY                = 100 ; int getpriority(int which, int who);
if defined COMPAT
	SYS_SEND                       = 101 ; int send(int s, caddr_t buf, int len, int flags);
	SYS_RECV                       = 102 ; int recv(int s, caddr_t buf, int len, int flags);
	SYS_SIGRETURN                  = 103 ; int sigreturn( struct osigcontext *sigcntxp);
end if
	SYS_BIND                       = 104 ; int bind(int s, caddr_t name, int namelen);
	SYS_SETSOCKOPT                 = 105 ; int setsockopt(int s, int level, int name, caddr_t val, int valsize);
	SYS_LISTEN                     = 106 ; int listen(int s, int backlog);
	;SYS_VTIMES                    = 107 ; OBSOL
if defined COMPAT
	SYS_SIGVEC                     = 108 ; int sigvec(int signum, struct sigvec *nsv, struct sigvec *osv);
	SYS_SIGBLOCK                   = 109 ; int sigblock(int mask);
	SYS_SIGSETMASK                 = 110 ; int sigsetmask(int mask);
	SYS_SIGSUSPEND                 = 111 ; int sigsuspend(osigset_t mask);
; XXX note nonstandard (bogus) calling convention - the libc stub passes
; us the mask, not a pointer to it.
	SYS_SIGSTACK                   = 112 ; int sigstack(struct sigstack *nss, struct sigstack *oss);
	SYS_RECVMSG                    = 113 ; int recvmsg(int s, struct omsghdr *msg, int flags);
	SYS_SENDMSG                    = 114 ; int sendmsg(int s, caddr_t msg, int flags);
end if
	;SYS_VTRACE                    = 115 ; OBSOL
	SYS_GETTIMEOFDAY               = 116 ; int gettimeofday(struct timeval *tp, struct timezone *tzp);
	SYS_GETRUSAGE                  = 117 ; int getrusage(int who, struct rusage *rusage);
	SYS_GETSOCKOPT                 = 118 ; int getsockopt(int s, int level, int name, caddr_t val, int *avalsize);
	;SYS_RESUBA                    = 119 ; UNIMPL
	SYS_READV                      = 120 ; int readv(int fd, struct iovec *iovp, u_int iovcnt);
	SYS_WRITEV                     = 121 ; int writev(int fd, struct iovec *iovp, u_int iovcnt);
	SYS_SETTIMEOFDAY               = 122 ; int settimeofday(struct timeval *tv, struct timezone *tzp);
	SYS_FCHOWN                     = 123 ; int fchown(int fd, int uid, int gid);
	SYS_FCHMOD                     = 124 ; int fchmod(int fd, int mode);
if defined COMPAT
	SYS_RECVFROM                   = 125 ; int recvfrom(int s, caddr_t buf, size_t len, int flags, caddr_t from, int *fromlenaddr);
end if
	SYS_SETREUID                   = 126 ; int setreuid(int ruid, int euid);
	SYS_SETREGID                   = 127 ; int setregid(int rgid, int egid);
	SYS_RENAME                     = 128 ; int rename(char *from, char *to);
if defined COMPAT
	SYS_TRUNCATE                   = 129 ; int truncate(char *path, long length);
	SYS_FTRUNCATE                  = 130 ; int ftruncate(int fd, long length);
end if
	SYS_FLOCK                      = 131 ; int flock(int fd, int how);
	SYS_MKFIFO                     = 132 ; int mkfifo(char *path, int mode);
	SYS_SENDTO                     = 133 ; int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, int tolen);
	SYS_SHUTDOWN                   = 134 ; int shutdown(int s, int how);
	SYS_SOCKETPAIR                 = 135 ; int socketpair(int domain, int type, int protocol, int *rsv);
	SYS_MKDIR                      = 136 ; int mkdir(char *path, int mode);
	SYS_RMDIR                      = 137 ; int rmdir(char *path);
	SYS_UTIMES                     = 138 ; int utimes(char *path, struct timeval *tptr);
	;SYS_4                         = 139 ; OBSOL
	SYS_ADJTIME                    = 140 ; int adjtime(struct timeval *delta, struct timeval *olddelta);
if defined COMPAT
	SYS_GETPEERNAME                = 141 ; int getpeername(int fdes, caddr_t asa, int *alen);
	SYS_GETHOSTID                  = 142 ; long gethostid(void);
	SYS_SETHOSTID                  = 143 ; int sethostid(long hostid);
	SYS_GETRLIMIT                  = 144 ; int getrlimit(u_int which, struct orlimit *rlp);
	SYS_SETRLIMIT                  = 145 ; int setrlimit(u_int which, struct orlimit *rlp);
	SYS_KILLPG                     = 146 ; int killpg(int pgid, int signum);
end if
	SYS_SETSID                     = 147 ; int setsid(void);
	SYS_QUOTACTL                   = 148 ; int quotactl(char *path, int cmd, int uid, caddr_t arg);
if defined COMPAT
	SYS_QUOTA                      = 149 ; int quota(void);
	SYS_GETSOCKNAME                = 150 ; int getsockname(int fdec, caddr_t asa, int *alen);

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
end if
	;SYS_SEM_LOCK                  = 151 ; UNIMPL
	;SYS_SEM_WAKEUP                = 152 ; UNIMPL
	;SYS_ASYNCDAEMON               = 153 ; UNIMPL
; 154 is initialised by the NLM code, if present.
if defined NOSTD
	SYS_NLM_SYSCALL                = 154 ; int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs);
; 155 is initialized by the NFS code, if present.
	SYS_NFSSVC                     = 155 ; int nfssvc(int flag, caddr_t argp);
end if
if defined COMPAT
	SYS_GETDIRENTRIES              = 156 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
end if
if defined COMPAT4
	SYS_STATFS                     = 157 ; int statfs(char *path, struct ostatfs *buf);
	SYS_FSTATFS                    = 158 ; int fstatfs(int fd, struct ostatfs *buf);
end if
	;SYS_NOSYS                     = 159 ; UNIMPL
	SYS_LGETFH                     = 160 ; int lgetfh(char *fname, struct fhandle *fhp);
	SYS_GETFH                      = 161 ; int getfh(char *fname, struct fhandle *fhp);
if defined COMPAT4
	SYS_GETDOMAINNAME              = 162 ; int getdomainname(char *domainname, int len);
	SYS_SETDOMAINNAME              = 163 ; int setdomainname(char *domainname, int len);
	SYS_UNAME                      = 164 ; int uname(struct utsname *name);
end if
	SYS_SYSARCH                    = 165 ; int sysarch(int op, char *parms);
	SYS_RTPRIO                     = 166 ; int rtprio(int function, pid_t pid, struct rtprio *rtp);
	;SYS_NOSYS                     = 167 ; UNIMPL
	;SYS_NOSYS                     = 168 ; UNIMPL
if defined NOSTD
	SYS_SEMSYS                     = 169 ; int semsys(int which, int a2, int a3, int a4, int a5);
; XXX should be	{ int semsys(int which, ...); }
	SYS_MSGSYS                     = 170 ; int msgsys(int which, int a2, int a3, int a4, int a5, int a6);
; XXX should be	{ int msgsys(int which, ...); }
	SYS_SHMSYS                     = 171 ; int shmsys(int which, int a2, int a3, int a4);
; XXX should be	{ int shmsys(int which, ...); }
end if
	;SYS_NOSYS                     = 172 ; UNIMPL
	SYS_FREEBSD6_PREAD             = 173 ; ssize_t freebsd6_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset);
	SYS_FREEBSD6_PWRITE            = 174 ; ssize_t freebsd6_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset);
	SYS_SETFIB                     = 175 ; int setfib(int fibnum);
	SYS_NTP_ADJTIME                = 176 ; int ntp_adjtime(struct timex *tp);
	;SYS_SFORK                     = 177 ; UNIMPL
	;SYS_GETDESCRIPTOR             = 178 ; UNIMPL
	;SYS_SETDESCRIPTOR             = 179 ; UNIMPL
	;SYS_NOSYS                     = 180 ; UNIMPL

; Syscalls 181-199 are used by/reserved for BSD
	SYS_SETGID                     = 181 ; int setgid(gid_t gid);
	SYS_SETEGID                    = 182 ; int setegid(gid_t egid);
	SYS_SETEUID                    = 183 ; int seteuid(uid_t euid);
	;SYS_LFS_BMAPV                 = 184 ; UNIMPL
	;SYS_LFS_MARKV                 = 185 ; UNIMPL
	;SYS_LFS_SEGCLEAN              = 186 ; UNIMPL
	;SYS_LFS_SEGWAIT               = 187 ; UNIMPL
	SYS_STAT                       = 188 ; int stat(char *path, struct stat *ub);
	SYS_FSTAT                      = 189 ; int fstat(int fd, struct stat *sb);
	SYS_LSTAT                      = 190 ; int lstat(char *path, struct stat *ub);
	SYS_PATHCONF                   = 191 ; int pathconf(char *path, int name);
	SYS_FPATHCONF                  = 192 ; int fpathconf(int fd, int name);
	;SYS_NOSYS                     = 193 ; UNIMPL
	SYS_GETRLIMIT                  = 194 ; int getrlimit(u_int which, struct rlimit *rlp);
	SYS_SETRLIMIT                  = 195 ; int setrlimit(u_int which, struct rlimit *rlp);
	SYS_GETDIRENTRIES              = 196 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
	SYS_FREEBSD6_MMAP              = 197 ; caddr_t freebsd6_mmap(caddr_t addr, size_t len, int prot, int flags, int fd, int pad, off_t pos);
	;SYS_NOSYS                     = 198 ; int nosys(void);
	SYS_FREEBSD6_LSEEK             = 199 ; off_t freebsd6_lseek(int fd, int pad, off_t offset, int whence);
	SYS_FREEBSD6_TRUNCATE          = 200 ; int freebsd6_truncate(char *path, int pad, off_t length);
	SYS_FREEBSD6_FTRUNCATE         = 201 ; int freebsd6_ftruncate(int fd, int pad, off_t length);
	SYS___SYSCTL                   = 202 ; int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen);
	SYS_MLOCK                      = 203 ; int mlock(const void *addr, size_t len);
	SYS_MUNLOCK                    = 204 ; int munlock(const void *addr, size_t len);
	SYS_UNDELETE                   = 205 ; int undelete(char *path);
	SYS_FUTIMES                    = 206 ; int futimes(int fd, struct timeval *tptr);
	SYS_GETPGID                    = 207 ; int getpgid(pid_t pid);
	;SYS_NEWREBOOT                 = 208 ; UNIMPL
	SYS_POLL                       = 209 ; int poll(struct pollfd *fds, u_int nfds, int timeout);

;
; The following are reserved for loadable syscalls
;
	;SYS_LKMNOSYS                  = 210 ; NODEF
	;SYS_LKMNOSYS                  = 211 ; NODEF
	;SYS_LKMNOSYS                  = 212 ; NODEF
	;SYS_LKMNOSYS                  = 213 ; NODEF
	;SYS_LKMNOSYS                  = 214 ; NODEF
	;SYS_LKMNOSYS                  = 215 ; NODEF
	;SYS_LKMNOSYS                  = 216 ; NODEF
	;SYS_LKMNOSYS                  = 217 ; NODEF
	;SYS_LKMNOSYS                  = 218 ; NODEF
	;SYS_LKMNOSYS                  = 219 ; NODEF

;
; The following were introduced with NetBSD/4.4Lite-2
if defined COMPAT7
	SYS___SEMCTL                   = 220 ; int __semctl(int semid, int semnum, int cmd, union semun_old *arg);
end if
if defined NOSTD
	SYS_SEMGET                     = 221 ; int semget(key_t key, int nsems, int semflg);
	SYS_SEMOP                      = 222 ; int semop(int semid, struct sembuf *sops, size_t nsops);
end if
	;SYS_SEMCONFIG                 = 223 ; UNIMPL
if defined COMPAT7
	SYS_MSGCTL                     = 224 ; int msgctl(int msqid, int cmd, struct msqid_ds_old *buf);
end if
if defined NOSTD
	SYS_MSGGET                     = 225 ; int msgget(key_t key, int msgflg);
	SYS_MSGSND                     = 226 ; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
	SYS_MSGRCV                     = 227 ; int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
	SYS_SHMAT                      = 228 ; int shmat(int shmid, const void *shmaddr, int shmflg);
end if
if defined COMPAT7
	SYS_SHMCTL                     = 229 ; int shmctl(int shmid, int cmd, struct shmid_ds_old *buf);
end if
if defined NOSTD
	SYS_SHMDT                      = 230 ; int shmdt(const void *shmaddr);
	SYS_SHMGET                     = 231 ; int shmget(key_t key, size_t size, int shmflg);
;
end if
	SYS_CLOCK_GETTIME              = 232 ; int clock_gettime(clockid_t clock_id, struct timespec *tp);
	SYS_CLOCK_SETTIME              = 233 ; int clock_settime( clockid_t clock_id, const struct timespec *tp);
	SYS_CLOCK_GETRES               = 234 ; int clock_getres(clockid_t clock_id, struct timespec *tp);
	SYS_KTIMER_CREATE              = 235 ; int ktimer_create(clockid_t clock_id, struct sigevent *evp, int *timerid);
	SYS_KTIMER_DELETE              = 236 ; int ktimer_delete(int timerid);
	SYS_KTIMER_SETTIME             = 237 ; int ktimer_settime(int timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
	SYS_KTIMER_GETTIME             = 238 ; int ktimer_gettime(int timerid, struct itimerspec *value);
	SYS_KTIMER_GETOVERRUN          = 239 ; int ktimer_getoverrun(int timerid);
	SYS_NANOSLEEP                  = 240 ; int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
	;SYS_NOSYS                     = 241 ; UNIMPL
	;SYS_NOSYS                     = 242 ; UNIMPL
	;SYS_NOSYS                     = 243 ; UNIMPL
	;SYS_NOSYS                     = 244 ; UNIMPL
	;SYS_NOSYS                     = 245 ; UNIMPL
	;SYS_NOSYS                     = 246 ; UNIMPL
	;SYS_NOSYS                     = 247 ; UNIMPL
	SYS_NTP_GETTIME                = 248 ; int ntp_gettime(struct ntptimeval *ntvp);
	;SYS_NOSYS                     = 249 ; UNIMPL
; syscall numbers initially used in OpenBSD
	SYS_MINHERIT                   = 250 ; int minherit(void *addr, size_t len, int inherit);
	SYS_RFORK                      = 251 ; int rfork(int flags);
	SYS_OPENBSD_POLL               = 252 ; int openbsd_poll(struct pollfd *fds, u_int nfds, int timeout);
	SYS_ISSETUGID                  = 253 ; int issetugid(void);
	SYS_LCHOWN                     = 254 ; int lchown(char *path, int uid, int gid);
if defined NOSTD
	SYS_AIO_READ                   = 255 ; int aio_read(struct aiocb *aiocbp);
	SYS_AIO_WRITE                  = 256 ; int aio_write(struct aiocb *aiocbp);
	SYS_LIO_LISTIO                 = 257 ; int lio_listio(int mode, struct aiocb * const *acb_list, int nent, struct sigevent *sig);
end if
	;SYS_NOSYS                     = 258 ; UNIMPL
	;SYS_NOSYS                     = 259 ; UNIMPL
	;SYS_NOSYS                     = 260 ; UNIMPL
	;SYS_NOSYS                     = 261 ; UNIMPL
	;SYS_NOSYS                     = 262 ; UNIMPL
	;SYS_NOSYS                     = 263 ; UNIMPL
	;SYS_NOSYS                     = 264 ; UNIMPL
	;SYS_NOSYS                     = 265 ; UNIMPL
	;SYS_NOSYS                     = 266 ; UNIMPL
	;SYS_NOSYS                     = 267 ; UNIMPL
	;SYS_NOSYS                     = 268 ; UNIMPL
	;SYS_NOSYS                     = 269 ; UNIMPL
	;SYS_NOSYS                     = 270 ; UNIMPL
	;SYS_NOSYS                     = 271 ; UNIMPL
	SYS_GETDENTS                   = 272 ; int getdents(int fd, char *buf, size_t count);
	;SYS_NOSYS                     = 273 ; UNIMPL
	SYS_LCHMOD                     = 274 ; int lchmod(char *path, mode_t mode);
	SYS_LCHOWN                     = 275 ; int lchown(char *path, uid_t uid, gid_t gid);
	SYS_LUTIMES                    = 276 ; int lutimes(char *path, struct timeval *tptr);
	SYS_MSYNC                      = 277 ; int msync(void *addr, size_t len, int flags);
	SYS_NSTAT                      = 278 ; int nstat(char *path, struct nstat *ub);
	SYS_NFSTAT                     = 279 ; int nfstat(int fd, struct nstat *sb);
	SYS_NLSTAT                     = 280 ; int nlstat(char *path, struct nstat *ub);
	;SYS_NOSYS                     = 281 ; UNIMPL
	;SYS_NOSYS                     = 282 ; UNIMPL
	;SYS_NOSYS                     = 283 ; UNIMPL
	;SYS_NOSYS                     = 284 ; UNIMPL
	;SYS_NOSYS                     = 285 ; UNIMPL
	;SYS_NOSYS                     = 286 ; UNIMPL
	;SYS_NOSYS                     = 287 ; UNIMPL
	;SYS_NOSYS                     = 288 ; UNIMPL
; 289 and 290 from NetBSD (OpenBSD: 267 and 268)
	SYS_PREADV                     = 289 ; ssize_t preadv(int fd, struct iovec *iovp, u_int iovcnt, off_t offset);
	SYS_PWRITEV                    = 290 ; ssize_t pwritev(int fd, struct iovec *iovp, u_int iovcnt, off_t offset);
	;SYS_NOSYS                     = 291 ; UNIMPL
	;SYS_NOSYS                     = 292 ; UNIMPL
	;SYS_NOSYS                     = 293 ; UNIMPL
	;SYS_NOSYS                     = 294 ; UNIMPL
	;SYS_NOSYS                     = 295 ; UNIMPL
	;SYS_NOSYS                     = 296 ; UNIMPL
; XXX 297 is 300 in NetBSD
if defined COMPAT4
	SYS_FHSTATFS                   = 297 ; int fhstatfs( const struct fhandle *u_fhp, struct ostatfs *buf);
end if
	SYS_FHOPEN                     = 298 ; int fhopen(const struct fhandle *u_fhp, int flags);
	SYS_FHSTAT                     = 299 ; int fhstat(const struct fhandle *u_fhp, struct stat *sb);
; syscall numbers for FreeBSD
	SYS_MODNEXT                    = 300 ; int modnext(int modid);
	SYS_MODSTAT                    = 301 ; int modstat(int modid, struct module_stat *stat);
	SYS_MODFNEXT                   = 302 ; int modfnext(int modid);
	SYS_MODFIND                    = 303 ; int modfind(const char *name);
	SYS_KLDLOAD                    = 304 ; int kldload(const char *file);
	SYS_KLDUNLOAD                  = 305 ; int kldunload(int fileid);
	SYS_KLDFIND                    = 306 ; int kldfind(const char *file);
	SYS_KLDNEXT                    = 307 ; int kldnext(int fileid);
	SYS_KLDSTAT                    = 308 ; int kldstat(int fileid, struct kld_file_stat* stat);
	SYS_KLDFIRSTMOD                = 309 ; int kldfirstmod(int fileid);
	SYS_GETSID                     = 310 ; int getsid(pid_t pid);
	SYS_SETRESUID                  = 311 ; int setresuid(uid_t ruid, uid_t euid, uid_t suid);
	SYS_SETRESGID                  = 312 ; int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
	;SYS_SIGNANOSLEEP              = 313 ; OBSOL
if defined NOSTD
	SYS_AIO_RETURN                 = 314 ; int aio_return(struct aiocb *aiocbp);
	SYS_AIO_SUSPEND                = 315 ; int aio_suspend( struct aiocb * const * aiocbp, int nent, const struct timespec *timeout);
	SYS_AIO_CANCEL                 = 316 ; int aio_cancel(int fd, struct aiocb *aiocbp);
	SYS_AIO_ERROR                  = 317 ; int aio_error(struct aiocb *aiocbp);
	SYS_OAIO_READ                  = 318 ; int oaio_read(struct oaiocb *aiocbp);
	SYS_OAIO_WRITE                 = 319 ; int oaio_write(struct oaiocb *aiocbp);
	SYS_OLIO_LISTIO                = 320 ; int olio_listio(int mode, struct oaiocb * const *acb_list, int nent, struct osigevent *sig);
end if
	SYS_YIELD                      = 321 ; int yield(void);
	;SYS_THR_SLEEP                 = 322 ; OBSOL
	;SYS_THR_WAKEUP                = 323 ; OBSOL
	SYS_MLOCKALL                   = 324 ; int mlockall(int how);
	SYS_MUNLOCKALL                 = 325 ; int munlockall(void);
	SYS___GETCWD                   = 326 ; int __getcwd(u_char *buf, u_int buflen);

	SYS_SCHED_SETPARAM             = 327 ; int sched_setparam (pid_t pid, const struct sched_param *param);
	SYS_SCHED_GETPARAM             = 328 ; int sched_getparam (pid_t pid, struct sched_param *param);

	SYS_SCHED_SETSCHEDULER         = 329 ; int sched_setscheduler (pid_t pid, int policy, const struct sched_param *param);
	SYS_SCHED_GETSCHEDULER         = 330 ; int sched_getscheduler (pid_t pid);

	SYS_SCHED_YIELD                = 331 ; int sched_yield (void);
	SYS_SCHED_GET_PRIORITY_MAX     = 332 ; int sched_get_priority_max (int policy);
	SYS_SCHED_GET_PRIORITY_MIN     = 333 ; int sched_get_priority_min (int policy);
	SYS_SCHED_RR_GET_INTERVAL      = 334 ; int sched_rr_get_interval (pid_t pid, struct timespec *interval);
	SYS_UTRACE                     = 335 ; int utrace(const void *addr, size_t len);
if defined COMPAT4
	SYS_SENDFILE                   = 336 ; int sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags);
end if
	SYS_KLDSYM                     = 337 ; int kldsym(int fileid, int cmd, void *data);
	SYS_JAIL                       = 338 ; int jail(struct jail *jail);
if defined NOSTD
	SYS_NNPFS_SYSCALL              = 339 ; int nnpfs_syscall(int operation, char *a_pathP, int a_opcode, void *a_paramsP, int a_followSymlinks);
end if
	SYS_SIGPROCMASK                = 340 ; int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
	SYS_SIGSUSPEND                 = 341 ; int sigsuspend(const sigset_t *sigmask);
if defined COMPAT4
	SYS_SIGACTION                  = 342 ; int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
end if
	SYS_SIGPENDING                 = 343 ; int sigpending(sigset_t *set);
if defined COMPAT4
	SYS_SIGRETURN                  = 344 ; int sigreturn( const struct ucontext4 *sigcntxp);
end if
	SYS_SIGTIMEDWAIT               = 345 ; int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);
	SYS_SIGWAITINFO                = 346 ; int sigwaitinfo(const sigset_t *set, siginfo_t *info);
	SYS___ACL_GET_FILE             = 347 ; int __acl_get_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_SET_FILE             = 348 ; int __acl_set_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_GET_FD               = 349 ; int __acl_get_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS___ACL_SET_FD               = 350 ; int __acl_set_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS___ACL_DELETE_FILE          = 351 ; int __acl_delete_file(const char *path, acl_type_t type);
	SYS___ACL_DELETE_FD            = 352 ; int __acl_delete_fd(int filedes, acl_type_t type);
	SYS___ACL_ACLCHECK_FILE        = 353 ; int __acl_aclcheck_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_ACLCHECK_FD          = 354 ; int __acl_aclcheck_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS_EXTATTRCTL                 = 355 ; int extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname);
	SYS_EXTATTR_SET_FILE           = 356 ; int extattr_set_file( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_GET_FILE           = 357 ; ssize_t extattr_get_file( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_FILE        = 358 ; int extattr_delete_file(const char *path, int attrnamespace, const char *attrname);
if defined NOSTD
	SYS_AIO_WAITCOMPLETE           = 359 ; int aio_waitcomplete( struct aiocb **aiocbp, struct timespec *timeout);
end if
	SYS_GETRESUID                  = 360 ; int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
	SYS_GETRESGID                  = 361 ; int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
	SYS_KQUEUE                     = 362 ; int kqueue(void);
	SYS_KEVENT                     = 363 ; int kevent(int fd, struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);
	;SYS___CAP_GET_PROC            = 364 ; UNIMPL
	;SYS___CAP_SET_PROC            = 365 ; UNIMPL
	;SYS___CAP_GET_FD              = 366 ; UNIMPL
	;SYS___CAP_GET_FILE            = 367 ; UNIMPL
	;SYS___CAP_SET_FD              = 368 ; UNIMPL
	;SYS___CAP_SET_FILE            = 369 ; UNIMPL
	;SYS_NOSYS                     = 370 ; UNIMPL
	SYS_EXTATTR_SET_FD             = 371 ; int extattr_set_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_GET_FD             = 372 ; ssize_t extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_FD          = 373 ; int extattr_delete_fd(int fd, int attrnamespace, const char *attrname);
	SYS___SETUGID                  = 374 ; int __setugid(int flag);
	;SYS_NFSCLNT                   = 375 ; UNIMPL
	SYS_EACCESS                    = 376 ; int eaccess(char *path, int flags);
if defined NOSTD
	SYS_AFS3_SYSCALL               = 377 ; int afs3_syscall(long syscall, long parm1, long parm2, long parm3, long parm4, long parm5, long parm6);
end if
	SYS_NMOUNT                     = 378 ; int nmount(struct iovec *iovp, unsigned int iovcnt, int flags);
	;SYS_KSE_EXIT                  = 379 ; UNIMPL
	;SYS_KSE_WAKEUP                = 380 ; UNIMPL
	;SYS_KSE_CREATE                = 381 ; UNIMPL
	;SYS_KSE_THR_INTERRUPT         = 382 ; UNIMPL
	;SYS_KSE_RELEASE               = 383 ; UNIMPL
	SYS___MAC_GET_PROC             = 384 ; int __mac_get_proc(struct mac *mac_p);
	SYS___MAC_SET_PROC             = 385 ; int __mac_set_proc(struct mac *mac_p);
	SYS___MAC_GET_FD               = 386 ; int __mac_get_fd(int fd, struct mac *mac_p);
	SYS___MAC_GET_FILE             = 387 ; int __mac_get_file(const char *path_p, struct mac *mac_p);
	SYS___MAC_SET_FD               = 388 ; int __mac_set_fd(int fd, struct mac *mac_p);
	SYS___MAC_SET_FILE             = 389 ; int __mac_set_file(const char *path_p, struct mac *mac_p);
	SYS_KENV                       = 390 ; int kenv(int what, const char *name, char *value, int len);
	SYS_LCHFLAGS                   = 391 ; int lchflags(const char *path, int flags);
	SYS_UUIDGEN                    = 392 ; int uuidgen(struct uuid *store, int count);
	SYS_SENDFILE                   = 393 ; int sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags);
	SYS_MAC_SYSCALL                = 394 ; int mac_syscall(const char *policy, int call, void *arg);
	SYS_GETFSSTAT                  = 395 ; int getfsstat(struct statfs *buf, long bufsize, int flags);
	SYS_STATFS                     = 396 ; int statfs(char *path, struct statfs *buf);
	SYS_FSTATFS                    = 397 ; int fstatfs(int fd, struct statfs *buf);
	SYS_FHSTATFS                   = 398 ; int fhstatfs(const struct fhandle *u_fhp, struct statfs *buf);
	;SYS_NOSYS                     = 399 ; UNIMPL
if defined NOSTD
	SYS_KSEM_CLOSE                 = 400 ; int ksem_close(semid_t id);
	SYS_KSEM_POST                  = 401 ; int ksem_post(semid_t id);
	SYS_KSEM_WAIT                  = 402 ; int ksem_wait(semid_t id);
	SYS_KSEM_TRYWAIT               = 403 ; int ksem_trywait(semid_t id);
	SYS_KSEM_INIT                  = 404 ; int ksem_init(semid_t *idp, unsigned int value);
	SYS_KSEM_OPEN                  = 405 ; int ksem_open(semid_t *idp, const char *name, int oflag, mode_t mode, unsigned int value);
	SYS_KSEM_UNLINK                = 406 ; int ksem_unlink(const char *name);
	SYS_KSEM_GETVALUE              = 407 ; int ksem_getvalue(semid_t id, int *val);
	SYS_KSEM_DESTROY               = 408 ; int ksem_destroy(semid_t id);
end if
	SYS___MAC_GET_PID              = 409 ; int __mac_get_pid(pid_t pid, struct mac *mac_p);
	SYS___MAC_GET_LINK             = 410 ; int __mac_get_link(const char *path_p, struct mac *mac_p);
	SYS___MAC_SET_LINK             = 411 ; int __mac_set_link(const char *path_p, struct mac *mac_p);
	SYS_EXTATTR_SET_LINK           = 412 ; int extattr_set_link( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_GET_LINK           = 413 ; ssize_t extattr_get_link( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_LINK        = 414 ; int extattr_delete_link( const char *path, int attrnamespace, const char *attrname);
	SYS___MAC_EXECVE               = 415 ; int __mac_execve(char *fname, char **argv, char **envv, struct mac *mac_p);
	SYS_SIGACTION                  = 416 ; int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
	SYS_SIGRETURN                  = 417 ; int sigreturn( const struct __ucontext *sigcntxp);
	;SYS___XSTAT                   = 418 ; UNIMPL
	;SYS___XFSTAT                  = 419 ; UNIMPL
	;SYS___XLSTAT                  = 420 ; UNIMPL
	SYS_GETCONTEXT                 = 421 ; int getcontext(struct __ucontext *ucp);
	SYS_SETCONTEXT                 = 422 ; int setcontext( const struct __ucontext *ucp);
	SYS_SWAPCONTEXT                = 423 ; int swapcontext(struct __ucontext *oucp, const struct __ucontext *ucp);
	SYS_SWAPOFF                    = 424 ; int swapoff(const char *name);
	SYS___ACL_GET_LINK             = 425 ; int __acl_get_link(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_SET_LINK             = 426 ; int __acl_set_link(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_DELETE_LINK          = 427 ; int __acl_delete_link(const char *path, acl_type_t type);
	SYS___ACL_ACLCHECK_LINK        = 428 ; int __acl_aclcheck_link(const char *path, acl_type_t type, struct acl *aclp);
	SYS_SIGWAIT                    = 429 ; int sigwait(const sigset_t *set, int *sig);
	SYS_THR_CREATE                 = 430 ; int thr_create(ucontext_t *ctx, long *id, int flags);
	SYS_THR_EXIT                   = 431 ; void thr_exit(long *state);
	SYS_THR_SELF                   = 432 ; int thr_self(long *id);
	SYS_THR_KILL                   = 433 ; int thr_kill(long id, int sig);
	SYS__UMTX_LOCK                 = 434 ; int _umtx_lock(struct umtx *umtx);
	SYS__UMTX_UNLOCK               = 435 ; int _umtx_unlock(struct umtx *umtx);
	SYS_JAIL_ATTACH                = 436 ; int jail_attach(int jid);
	SYS_EXTATTR_LIST_FD            = 437 ; ssize_t extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes);
	SYS_EXTATTR_LIST_FILE          = 438 ; ssize_t extattr_list_file( const char *path, int attrnamespace, void *data, size_t nbytes);
	SYS_EXTATTR_LIST_LINK          = 439 ; ssize_t extattr_list_link( const char *path, int attrnamespace, void *data, size_t nbytes);
	;SYS_KSE_SWITCHIN              = 440 ; UNIMPL
if defined NOSTD
	SYS_KSEM_TIMEDWAIT             = 441 ; int ksem_timedwait(semid_t id, const struct timespec *abstime);
end if
	SYS_THR_SUSPEND                = 442 ; int thr_suspend( const struct timespec *timeout);
	SYS_THR_WAKE                   = 443 ; int thr_wake(long id);
	SYS_KLDUNLOADF                 = 444 ; int kldunloadf(int fileid, int flags);
	SYS_AUDIT                      = 445 ; int audit(const void *record, u_int length);
	SYS_AUDITON                    = 446 ; int auditon(int cmd, void *data, u_int length);
	SYS_GETAUID                    = 447 ; int getauid(uid_t *auid);
	SYS_SETAUID                    = 448 ; int setauid(uid_t *auid);
	SYS_GETAUDIT                   = 449 ; int getaudit(struct auditinfo *auditinfo);
	SYS_SETAUDIT                   = 450 ; int setaudit(struct auditinfo *auditinfo);
	SYS_GETAUDIT_ADDR              = 451 ; int getaudit_addr( struct auditinfo_addr *auditinfo_addr, u_int length);
	SYS_SETAUDIT_ADDR              = 452 ; int setaudit_addr( struct auditinfo_addr *auditinfo_addr, u_int length);
	SYS_AUDITCTL                   = 453 ; int auditctl(char *path);
	SYS__UMTX_OP                   = 454 ; int _umtx_op(void *obj, int op, u_long val, void *uaddr1, void *uaddr2);
	SYS_THR_NEW                    = 455 ; int thr_new(struct thr_param *param, int param_size);
	SYS_SIGQUEUE                   = 456 ; int sigqueue(pid_t pid, int signum, void *value);
if defined NOSTD
	SYS_KMQ_OPEN                   = 457 ; int kmq_open(const char *path, int flags, mode_t mode, const struct mq_attr *attr);
	SYS_KMQ_SETATTR                = 458 ; int kmq_setattr(int mqd, const struct mq_attr *attr, struct mq_attr *oattr);
	SYS_KMQ_TIMEDRECEIVE           = 459 ; int kmq_timedreceive(int mqd, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec *abs_timeout);
	SYS_KMQ_TIMEDSEND              = 460 ; int kmq_timedsend(int mqd, const char *msg_ptr, size_t msg_len,unsigned msg_prio, const struct timespec *abs_timeout);
	SYS_KMQ_NOTIFY                 = 461 ; int kmq_notify(int mqd, const struct sigevent *sigev);
	SYS_KMQ_UNLINK                 = 462 ; int kmq_unlink(const char *path);
end if
	SYS_ABORT2                     = 463 ; int abort2(const char *why, int nargs, void **args);
	SYS_THR_SET_NAME               = 464 ; int thr_set_name(long id, const char *name);
if defined NOSTD
	SYS_AIO_FSYNC                  = 465 ; int aio_fsync(int op, struct aiocb *aiocbp);
end if
	SYS_RTPRIO_THREAD              = 466 ; int rtprio_thread(int function, lwpid_t lwpid, struct rtprio *rtp);
	;SYS_NOSYS                     = 467 ; UNIMPL
	;SYS_NOSYS                     = 468 ; UNIMPL
	;SYS___GETPATH_FROMFD          = 469 ; UNIMPL
	;SYS___GETPATH_FROMADDR        = 470 ; UNIMPL
	SYS_SCTP_PEELOFF               = 471 ; int sctp_peeloff(int sd, uint32_t name);
	SYS_SCTP_GENERIC_SENDMSG       = 472 ; int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, caddr_t to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags);
	SYS_SCTP_GENERIC_SENDMSG_IOV   = 473 ; int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, caddr_t to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags);
	SYS_SCTP_GENERIC_RECVMSG       = 474 ; int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, struct sockaddr * from, __socklen_t *fromlenaddr, struct sctp_sndrcvinfo *sinfo, int *msg_flags);
	SYS_PREAD                      = 475 ; ssize_t pread(int fd, void *buf, size_t nbyte, off_t offset);
	SYS_PWRITE                     = 476 ; ssize_t pwrite(int fd, const void *buf, size_t nbyte, off_t offset);
	SYS_MMAP                       = 477 ; caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos);
	SYS_LSEEK                      = 478 ; off_t lseek(int fd, off_t offset, int whence);
	SYS_TRUNCATE                   = 479 ; int truncate(char *path, off_t length);
	SYS_FTRUNCATE                  = 480 ; int ftruncate(int fd, off_t length);
	SYS_THR_KILL2                  = 481 ; int thr_kill2(pid_t pid, long id, int sig);
	SYS_SHM_OPEN                   = 482 ; int shm_open(const char *path, int flags, mode_t mode);
	SYS_SHM_UNLINK                 = 483 ; int shm_unlink(const char *path);
	SYS_CPUSET                     = 484 ; int cpuset(cpusetid_t *setid);
	SYS_CPUSET_SETID               = 485 ; int cpuset_setid(cpuwhich_t which, id_t id, cpusetid_t setid);
	SYS_CPUSET_GETID               = 486 ; int cpuset_getid(cpulevel_t level, cpuwhich_t which, id_t id, cpusetid_t *setid);
	SYS_CPUSET_GETAFFINITY         = 487 ; int cpuset_getaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, cpuset_t *mask);
	SYS_CPUSET_SETAFFINITY         = 488 ; int cpuset_setaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, const cpuset_t *mask);
	SYS_FACCESSAT                  = 489 ; int faccessat(int fd, char *path, int mode, int flag);
	SYS_FCHMODAT                   = 490 ; int fchmodat(int fd, char *path, mode_t mode, int flag);
	SYS_FCHOWNAT                   = 491 ; int fchownat(int fd, char *path, uid_t uid, gid_t gid, int flag);
	SYS_FEXECVE                    = 492 ; int fexecve(int fd, char **argv, char **envv);
	SYS_FSTATAT                    = 493 ; int fstatat(int fd, char *path, struct stat *buf, int flag);
	SYS_FUTIMESAT                  = 494 ; int futimesat(int fd, char *path, struct timeval *times);
	SYS_LINKAT                     = 495 ; int linkat(int fd1, char *path1, int fd2, char *path2, int flag);
	SYS_MKDIRAT                    = 496 ; int mkdirat(int fd, char *path, mode_t mode);
	SYS_MKFIFOAT                   = 497 ; int mkfifoat(int fd, char *path, mode_t mode);
	SYS_MKNODAT                    = 498 ; int mknodat(int fd, char *path, mode_t mode, dev_t dev);
; XXX: see the comment for open
	SYS_OPENAT                     = 499 ; int openat(int fd, char *path, int flag, mode_t mode);
	SYS_READLINKAT                 = 500 ; int readlinkat(int fd, char *path, char *buf, size_t bufsize);
	SYS_RENAMEAT                   = 501 ; int renameat(int oldfd, char *old, int newfd, char *new);
	SYS_SYMLINKAT                  = 502 ; int symlinkat(char *path1, int fd, char *path2);
	SYS_UNLINKAT                   = 503 ; int unlinkat(int fd, char *path, int flag);
	SYS_POSIX_OPENPT               = 504 ; int posix_openpt(int flags);
; 505 is initialised by the kgssapi code, if present.
if defined NOSTD
	SYS_GSSD_SYSCALL               = 505 ; int gssd_syscall(char *path);
end if
	SYS_JAIL_GET                   = 506 ; int jail_get(struct iovec *iovp, unsigned int iovcnt, int flags);
	SYS_JAIL_SET                   = 507 ; int jail_set(struct iovec *iovp, unsigned int iovcnt, int flags);
	SYS_JAIL_REMOVE                = 508 ; int jail_remove(int jid);
	SYS_CLOSEFROM                  = 509 ; int closefrom(int lowfd);
if defined NOSTD
	SYS___SEMCTL                   = 510 ; int __semctl(int semid, int semnum, int cmd, union semun *arg);
	SYS_MSGCTL                     = 511 ; int msgctl(int msqid, int cmd, struct msqid_ds *buf);
	SYS_SHMCTL                     = 512 ; int shmctl(int shmid, int cmd, struct shmid_ds *buf);
end if
	SYS_LPATHCONF                  = 513 ; int lpathconf(char *path, int name);
	;SYS_CAP_NEW                   = 514 ; UNIMPL
	;SYS_CAP_GETRIGHTS             = 515 ; UNIMPL
	;SYS_CAP_ENTER                 = 516 ; UNIMPL
	;SYS_CAP_GETMODE               = 517 ; UNIMPL
	;SYS_PDFORK                    = 518 ; UNIMPL
	;SYS_PDKILL                    = 519 ; UNIMPL
	;SYS_PDGETPID                  = 520 ; UNIMPL
	;SYS_PDWAIT                    = 521 ; UNIMPL
	SYS_PSELECT                    = 522 ; int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *sm);
; Please copy any additions and changes to the following compatability tables:
; sys/compat/freebsd32/syscalls.master


;==============================================
; Converted with FreeBSD_syscalls4fasm.pl v1.0.6
; https://github.com/graudeejs/asm4BSD/

; vim: set ts=8 sw=8 syn=fasm:
