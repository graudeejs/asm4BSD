; 	$NetBSD: syscalls.master,v 1.238 2010/09/07 17:10:08 pooka Exp $

;	@(#)syscalls.master	8.2 (Berkeley) 1/13/94

; NetBSD system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, IGNORED, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; Optional fields are specified after the type field
; (NOTE! they *must* be specified in this order):
;	MODULAR:attempt to autoload system call if not present
;	RUMP:	the system call can be called directly from rumps
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	IGNORED	syscall is a null op, but always succeeds
;	UNIMPL	unimplemented, not included in system
;	EXCL	implemented, but not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;	INDIR	included, but don't define the syscall args structure,
;		and allow it to be "really" varargs.
;
; arguments:
;	PAD	argument not part of the C interface, used only for padding
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ return_type|prefix|compat(optional)|basename(pseudo-proto); } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall names and switch definition files only.

; #include "opt_modular.h"
; #include "opt_ntp.h"
; #include "opt_sysv.h"

; #include <sys/param.h>
; #include <sys/systm.h>
; #include <sys/signal.h>
; #include <sys/mount.h>
; #include <sys/sched.h>
; #include <sys/syscallargs.h>

; %%

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

	SYS_SYSCALL                    = 0 ; int syscall(int code, ... register_t args[SYS_MAXSYSARGS]);
	SYS_EXIT                       = 1 ; void exit(int rval);
	SYS_FORK                       = 2 ; int fork(void);
	SYS_READ                       = 3 ; ssize_t read(int fd, void *buf, size_t nbyte);
	SYS_WRITE                      = 4 ; ssize_t write(int fd, const void *buf, size_t nbyte);
	SYS_OPEN                       = 5 ; int open(const char *path, int flags, ... mode_t mode);
	SYS_CLOSE                      = 6 ; int close(int fd);
if defined COMPAT_50
	SYS_WAIT4                      = 7 ; int wait4(int pid, int *status, int options, struct rusage50 *rusage);
end if
if defined COMPAT_43
	SYS_CREAT                      = 8 ; int creat(const char *path, mode_t mode);
end if
	SYS_LINK                       = 9 ; int link(const char *path, const char *link);
	SYS_UNLINK                     = 10 ; int unlink(const char *path);
	;SYS_EXECV                     = 11 ; OBSOL
	SYS_CHDIR                      = 12 ; int chdir(const char *path);
	SYS_FCHDIR                     = 13 ; int fchdir(int fd);
if defined COMPAT_50
	SYS_MKNOD                      = 14 ; int mknod(const char *path, mode_t mode, uint32_t dev);
end if
	SYS_CHMOD                      = 15 ; int chmod(const char *path, mode_t mode);
	SYS_CHOWN                      = 16 ; int chown(const char *path, uid_t uid, gid_t gid);
	SYS_OBREAK                     = 17 ; int obreak(char *nsize);
if defined COMPAT_20
	SYS_GETFSSTAT                  = 18 ; int getfsstat(struct statfs12 *buf, long bufsize, int flags);
end if
if defined COMPAT_43
	SYS_LSEEK                      = 19 ; long lseek(int fd, long offset, int whence);
end if
	SYS_GETPID_WITH_PPID           = 20 ; pid_t getpid_with_ppid(void);
if defined COMPAT_40
	SYS_MOUNT                      = 21 ; int mount(const char *type, const char *path, int flags, void *data);
end if
	SYS_UNMOUNT                    = 22 ; int unmount(const char *path, int flags);
	SYS_SETUID                     = 23 ; int setuid(uid_t uid);
	SYS_GETUID_WITH_EUID           = 24 ; uid_t getuid_with_euid(void);
	SYS_GETEUID                    = 25 ; uid_t geteuid(void);
	SYS_PTRACE                     = 26 ; int ptrace(int req, pid_t pid, void *addr, int data);
	SYS_RECVMSG                    = 27 ; ssize_t recvmsg(int s, struct msghdr *msg, int flags);
	SYS_SENDMSG                    = 28 ; ssize_t sendmsg(int s, const struct msghdr *msg, int flags);
	SYS_RECVFROM                   = 29 ; ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, unsigned int *fromlenaddr);
	SYS_ACCEPT                     = 30 ; int accept(int s, struct sockaddr *name, unsigned int *anamelen);
	SYS_GETPEERNAME                = 31 ; int getpeername(int fdes, struct sockaddr *asa, unsigned int *alen);
	SYS_GETSOCKNAME                = 32 ; int getsockname(int fdes, struct sockaddr *asa, unsigned int *alen);
	SYS_ACCESS                     = 33 ; int access(const char *path, int flags);
	SYS_CHFLAGS                    = 34 ; int chflags(const char *path, u_long flags);
	SYS_FCHFLAGS                   = 35 ; int fchflags(int fd, u_long flags);
	SYS_SYNC                       = 36 ; void sync(void);
	SYS_KILL                       = 37 ; int kill(int pid, int signum);
if defined COMPAT_43
	SYS_STAT                       = 38 ; int stat(const char *path, struct stat43 *ub);
end if
	SYS_GETPPID                    = 39 ; pid_t getppid(void);
if defined COMPAT_43
	SYS_LSTAT                      = 40 ; int lstat(const char *path, struct stat43 *ub);
end if
	SYS_DUP                        = 41 ; int dup(int fd);
	SYS_PIPE                       = 42 ; int pipe(void);
	SYS_GETEGID                    = 43 ; gid_t getegid(void);
	SYS_PROFIL                     = 44 ; int profil(char *samples, size_t size, u_long offset, u_int scale);
	SYS_KTRACE                     = 45 ; int ktrace(const char *fname, int ops, int facs, int pid);
if defined COMPAT_13
	SYS_SIGACTION                  = 46 ; int sigaction(int signum, const struct sigaction13 *nsa, struct sigaction13 *osa);
end if
	SYS_GETGID_WITH_EGID           = 47 ; gid_t getgid_with_egid(void);
if defined COMPAT_13
	SYS_SIGPROCMASK                = 48 ; int sigprocmask(int how, int mask);
end if
	SYS___GETLOGIN                 = 49 ; int __getlogin(char *namebuf, size_t namelen);
	SYS___SETLOGIN                 = 50 ; int __setlogin(const char *namebuf);
	SYS_ACCT                       = 51 ; int acct(const char *path);
if defined COMPAT_13
	SYS_SIGPENDING                 = 52 ; int sigpending(void);
	SYS_SIGALTSTACK                = 53 ; int sigaltstack( const struct sigaltstack13 *nss, struct sigaltstack13 *oss);
end if
	SYS_IOCTL                      = 54 ; int ioctl(int fd, u_long com, ... void *data);
if defined COMPAT_12
	SYS_REBOOT                     = 55 ; int reboot(int opt);
end if
	SYS_REVOKE                     = 56 ; int revoke(const char *path);
	SYS_SYMLINK                    = 57 ; int symlink(const char *path, const char *link);
	SYS_READLINK                   = 58 ; ssize_t readlink(const char *path, char *buf, size_t count);
	SYS_EXECVE                     = 59 ; int execve(const char *path, char * const *argp, char * const *envp);
	SYS_UMASK                      = 60 ; mode_t umask(mode_t newmask);
	SYS_CHROOT                     = 61 ; int chroot(const char *path);
if defined COMPAT_43
	SYS_FSTAT                      = 62 ; int fstat(int fd, struct stat43 *sb);
	SYS_GETKERNINFO                = 63 ; int getkerninfo(int op, char *where, int *size, int arg);
	SYS_GETPAGESIZE                = 64 ; int getpagesize(void);
end if
if defined COMPAT_12
	SYS_MSYNC                      = 65 ; int msync(void *addr, size_t len);
; XXX COMPAT_??? for 4.4BSD-compatible vfork(2)?
end if
	SYS_VFORK                      = 66 ; int vfork(void);
	;SYS_VREAD                     = 67 ; OBSOL
	;SYS_VWRITE                    = 68 ; OBSOL
	SYS_SBRK                       = 69 ; int sbrk(intptr_t incr);
	SYS_SSTK                       = 70 ; int sstk(int incr);
if defined COMPAT_43
	SYS_MMAP                       = 71 ; int mmap(void *addr, size_t len, int prot, int flags, int fd, long pos);
end if
	SYS_OVADVISE                   = 72 ; int ovadvise(int anom);
	SYS_MUNMAP                     = 73 ; int munmap(void *addr, size_t len);
	SYS_MPROTECT                   = 74 ; int mprotect(void *addr, size_t len, int prot);
	SYS_MADVISE                    = 75 ; int madvise(void *addr, size_t len, int behav);
	;SYS_VHANGUP                   = 76 ; OBSOL
	;SYS_VLIMIT                    = 77 ; OBSOL
	SYS_MINCORE                    = 78 ; int mincore(void *addr, size_t len, char *vec);
	SYS_GETGROUPS                  = 79 ; int getgroups(int gidsetsize, gid_t *gidset);
	SYS_SETGROUPS                  = 80 ; int setgroups(int gidsetsize, const gid_t *gidset);
	SYS_GETPGRP                    = 81 ; int getpgrp(void);
	SYS_SETPGID                    = 82 ; int setpgid(int pid, int pgid);
if defined COMPAT_50
	SYS_SETITIMER                  = 83 ; int setitimer(int which, const struct itimerval50 *itv, struct itimerval50 *oitv);
end if
if defined COMPAT_43
	SYS_WAIT                       = 84 ; int wait(void);
end if
if defined COMPAT_12
	SYS_SWAPON                     = 85 ; int swapon(const char *name);
end if
if defined COMPAT_50
	SYS_GETITIMER                  = 86 ; int getitimer(int which, struct itimerval50 *itv);
end if
if defined COMPAT_43
	SYS_GETHOSTNAME                = 87 ; int gethostname(char *hostname, u_int len);
	SYS_SETHOSTNAME                = 88 ; int sethostname(char *hostname, u_int len);
	SYS_GETDTABLESIZE              = 89 ; int getdtablesize(void);
end if
	SYS_DUP2                       = 90 ; int dup2(int from, int to);
	;SYS_GETDOPT                   = 91 ; UNIMPL
	SYS_FCNTL                      = 92 ; int fcntl(int fd, int cmd, ... void *arg);
if defined COMPAT_50
	SYS_SELECT                     = 93 ; int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval50 *tv);
end if
	;SYS_SETDOPT                   = 94 ; UNIMPL
	SYS_FSYNC                      = 95 ; int fsync(int fd);
	SYS_SETPRIORITY                = 96 ; int setpriority(int which, id_t who, int prio);
if defined COMPAT_30
	SYS_SOCKET                     = 97 ; int socket(int domain, int type, int protocol);
end if
	SYS_CONNECT                    = 98 ; int connect(int s, const struct sockaddr *name, unsigned int namelen);
if defined COMPAT_43
	SYS_ACCEPT                     = 99 ; int accept(int s, void *name, int *anamelen);
end if
	SYS_GETPRIORITY                = 100 ; int getpriority(int which, id_t who);
if defined COMPAT_43
	SYS_SEND                       = 101 ; int send(int s, void *buf, int len, int flags);
	SYS_RECV                       = 102 ; int recv(int s, void *buf, int len, int flags);
end if
if defined COMPAT_13
	SYS_SIGRETURN                  = 103 ; int sigreturn(struct sigcontext13 *sigcntxp);
end if
	SYS_BIND                       = 104 ; int bind(int s, const struct sockaddr *name, unsigned int namelen);
	SYS_SETSOCKOPT                 = 105 ; int setsockopt(int s, int level, int name, const void *val, unsigned int valsize);
	SYS_LISTEN                     = 106 ; int listen(int s, int backlog);
	;SYS_VTIMES                    = 107 ; OBSOL
if defined COMPAT_43
	SYS_SIGVEC                     = 108 ; int sigvec(int signum, struct sigvec *nsv, struct sigvec *osv);
	SYS_SIGBLOCK                   = 109 ; int sigblock(int mask);
	SYS_SIGSETMASK                 = 110 ; int sigsetmask(int mask);
end if
if defined COMPAT_13
	SYS_SIGSUSPEND                 = 111 ; int sigsuspend(int mask);
end if
if defined COMPAT_43
	SYS_SIGSTACK                   = 112 ; int sigstack(struct sigstack *nss, struct sigstack *oss);
	SYS_RECVMSG                    = 113 ; int recvmsg(int s, struct omsghdr *msg, int flags);
	SYS_SENDMSG                    = 114 ; int sendmsg(int s, void *msg, int flags);
end if
	;SYS_VTRACE                    = 115 ; OBSOL
if defined COMPAT_50
	SYS_GETTIMEOFDAY               = 116 ; int gettimeofday(struct timeval50 *tp, void *tzp);
	SYS_GETRUSAGE                  = 117 ; int getrusage(int who, struct rusage50 *rusage);
end if
	SYS_GETSOCKOPT                 = 118 ; int getsockopt(int s, int level, int name, void *val, unsigned int *avalsize);
	;SYS_RESUBA                    = 119 ; OBSOL
	SYS_READV                      = 120 ; ssize_t readv(int fd, const struct iovec *iovp, int iovcnt);
	SYS_WRITEV                     = 121 ; ssize_t writev(int fd, const struct iovec *iovp, int iovcnt);
if defined COMPAT_50
	SYS_SETTIMEOFDAY               = 122 ; int settimeofday(const struct timeval50 *tv, const void *tzp);
end if
	SYS_FCHOWN                     = 123 ; int fchown(int fd, uid_t uid, gid_t gid);
	SYS_FCHMOD                     = 124 ; int fchmod(int fd, mode_t mode);
if defined COMPAT_43
	SYS_RECVFROM                   = 125 ; int recvfrom(int s, void *buf, size_t len, int flags, void *from, int *fromlenaddr);
end if
	SYS_SETREUID                   = 126 ; int setreuid(uid_t ruid, uid_t euid);
	SYS_SETREGID                   = 127 ; int setregid(gid_t rgid, gid_t egid);
	SYS_RENAME                     = 128 ; int rename(const char *from, const char *to);
if defined COMPAT_43
	SYS_TRUNCATE                   = 129 ; int truncate(const char *path, long length);
	SYS_FTRUNCATE                  = 130 ; int ftruncate(int fd, long length);
end if
	SYS_FLOCK                      = 131 ; int flock(int fd, int how);
	SYS_MKFIFO                     = 132 ; int mkfifo(const char *path, mode_t mode);
	SYS_SENDTO                     = 133 ; ssize_t sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, unsigned int tolen);
	SYS_SHUTDOWN                   = 134 ; int shutdown(int s, int how);
	SYS_SOCKETPAIR                 = 135 ; int socketpair(int domain, int type, int protocol, int *rsv);
	SYS_MKDIR                      = 136 ; int mkdir(const char *path, mode_t mode);
	SYS_RMDIR                      = 137 ; int rmdir(const char *path);
if defined COMPAT_50
	SYS_UTIMES                     = 138 ; int utimes(const char *path, const struct timeval50 *tptr);
end if
	;SYS_4                         = 139 ; OBSOL
if defined COMPAT_50
	SYS_ADJTIME                    = 140 ; int adjtime(const struct timeval50 *delta, struct timeval50 *olddelta);
end if
if defined COMPAT_43
	SYS_GETPEERNAME                = 141 ; int getpeername(int fdes, void *asa, int *alen);
	SYS_GETHOSTID                  = 142 ; int32_t gethostid(void);
	SYS_SETHOSTID                  = 143 ; int sethostid(int32_t hostid);
	SYS_GETRLIMIT                  = 144 ; int getrlimit(int which, struct orlimit *rlp);
	SYS_SETRLIMIT                  = 145 ; int setrlimit(int which, const struct orlimit *rlp);
	SYS_KILLPG                     = 146 ; int killpg(int pgid, int signum);
end if
	SYS_SETSID                     = 147 ; int setsid(void);
	SYS_QUOTACTL                   = 148 ; int quotactl(const char *path, int cmd, int uid, void *arg);
if defined COMPAT_43
	SYS_QUOTA                      = 149 ; int quota(void);
	SYS_GETSOCKNAME                = 150 ; int getsockname(int fdec, void *asa, int *alen);

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
end if
	;151	UNIMPL
	;152	UNIMPL
	;153	UNIMPL
	;154	UNIMPL
	SYS_NFSSVC                     = 155 ; int nfssvc(int flag, void *argp);
if defined COMPAT_43
	SYS_GETDIRENTRIES              = 156 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
end if
if defined COMPAT_20
	SYS_STATFS                     = 157 ; int statfs(const char *path, struct statfs12 *buf);
	SYS_FSTATFS                    = 158 ; int fstatfs(int fd, struct statfs12 *buf);
end if
	;159	UNIMPL
	;160	UNIMPL
if defined COMPAT_30
	SYS_GETFH                      = 161 ; int getfh(const char *fname, struct compat_30_fhandle *fhp);
end if
if defined COMPAT_09
	SYS_GETDOMAINNAME              = 162 ; int getdomainname(char *domainname, int len);
	SYS_SETDOMAINNAME              = 163 ; int setdomainname(char *domainname, int len);
	SYS_UNAME                      = 164 ; int uname(struct outsname *name);
end if
	SYS_SYSARCH                    = 165 ; int sysarch(int op, void *parms);
	;166	UNIMPL
	;167	UNIMPL
	;168	UNIMPL
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
; #if (defined(SYSVSEM) || !defined(_KERNEL_OPT)) && !defined(_LP64)
if defined COMPAT_10
	SYS_SEMSYS                     = 169 ; int semsys(int which, int a2, int a3, int a4, int a5);
; #else
end if
	;SYS_1                         = 169 ; EXCL
; #endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
; #if (defined(SYSVMSG) || !defined(_KERNEL_OPT)) && !defined(_LP64)
if defined COMPAT_10
	SYS_MSGSYS                     = 170 ; int msgsys(int which, int a2, int a3, int a4, int a5, int a6);
; #else
end if
	;SYS_1                         = 170 ; EXCL
; #endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
; #if (defined(SYSVSHM) || !defined(_KERNEL_OPT)) && !defined(_LP64)
if defined COMPAT_10
	SYS_SHMSYS                     = 171 ; int shmsys(int which, int a2, int a3, int a4);
; #else
end if
	;SYS_1                         = 171 ; EXCL
; #endif
	;172	UNIMPL
	SYS_PREAD                      = 173 ; ssize_t pread(int fd, void *buf, size_t nbyte, int PAD, off_t offset);
	SYS_PWRITE                     = 174 ; ssize_t pwrite(int fd, const void *buf, size_t nbyte, int PAD, off_t offset);
; For some reason, ntp_gettime doesn't want to raise SIGSYS when it's excluded.
if defined COMPAT_30
	SYS_NTP_GETTIME                = 175 ; int ntp_gettime(struct ntptimeval30 *ntvp);
; #if defined(NTP) || !defined(_KERNEL_OPT)
end if
	SYS_NTP_ADJTIME                = 176 ; int ntp_adjtime(struct timex *tp);
; #else
	;SYS_NTP_ADJTIME               = 176 ; EXCL
; #endif
	;177	UNIMPL
	;178	UNIMPL
	;179	UNIMPL
	;180	UNIMPL

; Syscalls 180-199 are used by/reserved for BSD
	SYS_SETGID                     = 181 ; int setgid(gid_t gid);
	SYS_SETEGID                    = 182 ; int setegid(gid_t egid);
	SYS_SETEUID                    = 183 ; int seteuid(uid_t euid);
	SYS_LFS_BMAPV                  = 184 ; int lfs_bmapv(fsid_t *fsidp, struct block_info *blkiov, int blkcnt);
	SYS_LFS_MARKV                  = 185 ; int lfs_markv(fsid_t *fsidp, struct block_info *blkiov, int blkcnt);
	SYS_LFS_SEGCLEAN               = 186 ; int lfs_segclean(fsid_t *fsidp, u_long segment);
if defined COMPAT_50
	SYS_LFS_SEGWAIT                = 187 ; int lfs_segwait(fsid_t *fsidp, struct timeval50 *tv);
end if
if defined COMPAT_12
	SYS_STAT                       = 188 ; int stat(const char *path, struct stat12 *ub);
	SYS_FSTAT                      = 189 ; int fstat(int fd, struct stat12 *sb);
	SYS_LSTAT                      = 190 ; int lstat(const char *path, struct stat12 *ub);
end if
	SYS_PATHCONF                   = 191 ; long pathconf(const char *path, int name);
	SYS_FPATHCONF                  = 192 ; long fpathconf(int fd, int name);
	;193	UNIMPL
	SYS_GETRLIMIT                  = 194 ; int getrlimit(int which, struct rlimit *rlp);
	SYS_SETRLIMIT                  = 195 ; int setrlimit(int which, const struct rlimit *rlp);
if defined COMPAT_12
	SYS_GETDIRENTRIES              = 196 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
end if
	SYS_MMAP                       = 197 ; void * mmap(void *addr, size_t len, int prot, int flags, int fd, long PAD, off_t pos);
	SYS___SYSCALL                  = 198 ; quad_t __syscall(quad_t code, ... register_t args[SYS_MAXSYSARGS]);
	SYS_LSEEK                      = 199 ; off_t lseek(int fd, int PAD, off_t offset, int whence);
	SYS_TRUNCATE                   = 200 ; int truncate(const char *path, int PAD, off_t length);
	SYS_FTRUNCATE                  = 201 ; int ftruncate(int fd, int PAD, off_t length);
	SYS___SYSCTL                   = 202 ; int __sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, const void *new, size_t newlen);
	SYS_MLOCK                      = 203 ; int mlock(const void *addr, size_t len);
	SYS_MUNLOCK                    = 204 ; int munlock(const void *addr, size_t len);
	SYS_UNDELETE                   = 205 ; int undelete(const char *path);
if defined COMPAT_50
	SYS_FUTIMES                    = 206 ; int futimes(int fd, const struct timeval50 *tptr);
end if
	SYS_GETPGID                    = 207 ; pid_t getpgid(pid_t pid);
	SYS_REBOOT                     = 208 ; int reboot(int opt, char *bootstr);
	SYS_POLL                       = 209 ; int poll(struct pollfd *fds, u_int nfds, int timeout);
;
; Syscalls 210-219 are reserved for dynamically loaded syscalls
;
	;210	UNIMPL
	;211	UNIMPL
	;212	UNIMPL
	;213	UNIMPL
	;214	UNIMPL
	;215	UNIMPL
	;216	UNIMPL
	;217	UNIMPL
	;218	UNIMPL
	;219	UNIMPL
; System calls 220-300 are reserved for use by NetBSD
; #if defined(SYSVSEM) || !defined(_KERNEL_OPT)
if defined COMPAT_14
	SYS___SEMCTL                   = 220 ; int __semctl(int semid, int semnum, int cmd, union __semun *arg);
end if
	SYS_SEMGET                     = 221 ; int semget(key_t key, int nsems, int semflg);
	SYS_SEMOP                      = 222 ; int semop(int semid, struct sembuf *sops, size_t nsops);
	SYS_SEMCONFIG                  = 223 ; int semconfig(int flag);
; #else
	;SYS_COMPAT_14_SEMCTL          = 220 ; EXCL
	;SYS_SEMGET                    = 221 ; EXCL
	;SYS_SEMOP                     = 222 ; EXCL
	;SYS_SEMCONFIG                 = 223 ; EXCL
; #endif
; #if defined(SYSVMSG) || !defined(_KERNEL_OPT)
if defined COMPAT_14
	SYS_MSGCTL                     = 224 ; int msgctl(int msqid, int cmd, struct msqid_ds14 *buf);
end if
	SYS_MSGGET                     = 225 ; int msgget(key_t key, int msgflg);
	SYS_MSGSND                     = 226 ; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
	SYS_MSGRCV                     = 227 ; ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
; #else
	;SYS_COMPAT_14_MSGCTL          = 224 ; EXCL
	;SYS_MSGGET                    = 225 ; EXCL
	;SYS_MSGSND                    = 226 ; EXCL
	;SYS_MSGRCV                    = 227 ; EXCL
; #endif
; #if defined(SYSVSHM) || !defined(_KERNEL_OPT)
	SYS_SHMAT                      = 228 ; void * shmat(int shmid, const void *shmaddr, int shmflg);
if defined COMPAT_14
	SYS_SHMCTL                     = 229 ; int shmctl(int shmid, int cmd, struct shmid_ds14 *buf);
end if
	SYS_SHMDT                      = 230 ; int shmdt(const void *shmaddr);
	SYS_SHMGET                     = 231 ; int shmget(key_t key, size_t size, int shmflg);
; #else
	;SYS_SHMAT                     = 228 ; EXCL
	;SYS_COMPAT_14_SHMCTL          = 229 ; EXCL
	;SYS_SHMDT                     = 230 ; EXCL
	;SYS_SHMGET                    = 231 ; EXCL
; #endif
if defined COMPAT_50
	SYS_CLOCK_GETTIME              = 232 ; int clock_gettime(clockid_t clock_id, struct timespec50 *tp);
	SYS_CLOCK_SETTIME              = 233 ; int clock_settime(clockid_t clock_id, const struct timespec50 *tp);
	SYS_CLOCK_GETRES               = 234 ; int clock_getres(clockid_t clock_id, struct timespec50 *tp);
end if
	SYS_TIMER_CREATE               = 235 ; int timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid);
	SYS_TIMER_DELETE               = 236 ; int timer_delete(timer_t timerid);
if defined COMPAT_50
	SYS_TIMER_SETTIME              = 237 ; int timer_settime(timer_t timerid, int flags, const struct itimerspec50 *value, struct itimerspec50 *ovalue);
	SYS_TIMER_GETTIME              = 238 ; int timer_gettime(timer_t timerid, struct itimerspec50 *value);
end if
	SYS_TIMER_GETOVERRUN           = 239 ; int timer_getoverrun(timer_t timerid);
;
; Syscalls 240-269 are reserved for other IEEE Std1003.1b syscalls
;
if defined COMPAT_50
	SYS_NANOSLEEP                  = 240 ; int nanosleep(const struct timespec50 *rqtp, struct timespec50 *rmtp);
end if
	SYS_FDATASYNC                  = 241 ; int fdatasync(int fd);
	SYS_MLOCKALL                   = 242 ; int mlockall(int flags);
	SYS_MUNLOCKALL                 = 243 ; int munlockall(void);
if defined COMPAT_50
	SYS___SIGTIMEDWAIT             = 244 ; int __sigtimedwait(const sigset_t *set, siginfo_t *info, struct timespec50 *timeout);
end if
	;SYS_SIGQUEUE                  = 245 ; UNIMPL
	SYS_MODCTL                     = 246 ; int modctl(int cmd, void *arg);
	SYS__KSEM_INIT                 = 247 ; int _ksem_init(unsigned int value, intptr_t *idp);
	SYS__KSEM_OPEN                 = 248 ; int _ksem_open(const char *name, int oflag, mode_t mode, unsigned int value, intptr_t *idp);
	SYS__KSEM_UNLINK               = 249 ; int _ksem_unlink(const char *name);
	SYS__KSEM_CLOSE                = 250 ; int _ksem_close(intptr_t id);
	SYS__KSEM_POST                 = 251 ; int _ksem_post(intptr_t id);
	SYS__KSEM_WAIT                 = 252 ; int _ksem_wait(intptr_t id);
	SYS__KSEM_TRYWAIT              = 253 ; int _ksem_trywait(intptr_t id);
	SYS__KSEM_GETVALUE             = 254 ; int _ksem_getvalue(intptr_t id, unsigned int *value);
	SYS__KSEM_DESTROY              = 255 ; int _ksem_destroy(intptr_t id);
	;SYS__KSEM_TIMEDWAIT           = 256 ; UNIMPL
	SYS_MQ_OPEN                    = 257 ; mqd_t mq_open(const char * name, int oflag, mode_t mode, struct mq_attr *attr);
	SYS_MQ_CLOSE                   = 258 ; int mq_close(mqd_t mqdes);
	SYS_MQ_UNLINK                  = 259 ; int mq_unlink(const char *name);
	SYS_MQ_GETATTR                 = 260 ; int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat);
	SYS_MQ_SETATTR                 = 261 ; int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat);
	SYS_MQ_NOTIFY                  = 262 ; int mq_notify(mqd_t mqdes, const struct sigevent *notification);
	SYS_MQ_SEND                    = 263 ; int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio);
	SYS_MQ_RECEIVE                 = 264 ; ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio);
if defined COMPAT_50
	SYS_MQ_TIMEDSEND               = 265 ; int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec50 *abs_timeout);
	SYS_MQ_TIMEDRECEIVE            = 266 ; ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec50 *abs_timeout);
end if
	;267	UNIMPL
	;268	UNIMPL
	;269	UNIMPL
	SYS___POSIX_RENAME             = 270 ; int __posix_rename(const char *from, const char *to);
	SYS_SWAPCTL                    = 271 ; int swapctl(int cmd, void *arg, int misc);
if defined COMPAT_30
	SYS_GETDENTS                   = 272 ; int getdents(int fd, char *buf, size_t count);
end if
	SYS_MINHERIT                   = 273 ; int minherit(void *addr, size_t len, int inherit);
	SYS_LCHMOD                     = 274 ; int lchmod(const char *path, mode_t mode);
	SYS_LCHOWN                     = 275 ; int lchown(const char *path, uid_t uid, gid_t gid);
if defined COMPAT_50
	SYS_LUTIMES                    = 276 ; int lutimes(const char *path, const struct timeval50 *tptr);
end if
	SYS_MSYNC                      = 277 ; int msync(void *addr, size_t len, int flags);
if defined COMPAT_30
	SYS_STAT                       = 278 ; int stat(const char *path, struct stat13 *ub);
	SYS_FSTAT                      = 279 ; int fstat(int fd, struct stat13 *sb);
	SYS_LSTAT                      = 280 ; int lstat(const char *path, struct stat13 *ub);
end if
	SYS_SIGALTSTACK                = 281 ; int sigaltstack( const struct sigaltstack *nss, struct sigaltstack *oss);
	SYS_VFORK                      = 282 ; int vfork(void);
	SYS___POSIX_CHOWN              = 283 ; int __posix_chown(const char *path, uid_t uid, gid_t gid);
	SYS___POSIX_FCHOWN             = 284 ; int __posix_fchown(int fd, uid_t uid, gid_t gid);
	SYS___POSIX_LCHOWN             = 285 ; int __posix_lchown(const char *path, uid_t uid, gid_t gid);
	SYS_GETSID                     = 286 ; pid_t getsid(pid_t pid);
	SYS___CLONE                    = 287 ; pid_t __clone(int flags, void *stack);
	SYS_FKTRACE                    = 288 ; int fktrace(int fd, int ops, int facs, int pid);
	SYS_PREADV                     = 289 ; ssize_t preadv(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset);
	SYS_PWRITEV                    = 290 ; ssize_t pwritev(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset);
if defined COMPAT_16
	SYS_SIGACTION                  = 291 ; int sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa);
end if
	SYS_SIGPENDING                 = 292 ; int sigpending(sigset_t *set);
	SYS_SIGPROCMASK                = 293 ; int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
	SYS_SIGSUSPEND                 = 294 ; int sigsuspend(const sigset_t *set);
if defined COMPAT_16
	SYS_SIGRETURN                  = 295 ; int sigreturn(struct sigcontext *sigcntxp);
end if
	SYS___GETCWD                   = 296 ; int __getcwd(char *bufp, size_t length);
	SYS_FCHROOT                    = 297 ; int fchroot(int fd);
if defined COMPAT_30
	SYS_FHOPEN                     = 298 ; int fhopen(const struct compat_30_fhandle *fhp, int flags);
	SYS_FHSTAT                     = 299 ; int fhstat(const struct compat_30_fhandle *fhp, struct stat13 *sb);
end if
if defined COMPAT_20
	SYS_FHSTATFS                   = 300 ; int fhstatfs(const struct compat_30_fhandle *fhp, struct statfs12 *buf);
; #if defined(SYSVSEM) || !defined(_KERNEL_OPT)
end if
if defined COMPAT_50
	SYS___SEMCTL                   = 301 ; int __semctl(int semid, int semnum, int cmd, ... union __semun *arg);
; #else
end if
	;SYS_____SEMCTL13              = 301 ; EXCL
; #endif
; #if defined(SYSVMSG) || !defined(_KERNEL_OPT)
if defined COMPAT_50
	SYS_MSGCTL                     = 302 ; int msgctl(int msqid, int cmd, struct msqid_ds *buf);
; #else
end if
	;SYS___MSGCTL13                = 302 ; EXCL
; #endif
; #if defined(SYSVSHM) || !defined(_KERNEL_OPT)
if defined COMPAT_50
	SYS_SHMCTL                     = 303 ; int shmctl(int shmid, int cmd, struct shmid_ds13 *buf);
; #else
end if
	;SYS___SHMCTL13                = 303 ; EXCL
; #endif
	SYS_LCHFLAGS                   = 304 ; int lchflags(const char *path, u_long flags);
	SYS_ISSETUGID                  = 305 ; int issetugid(void);
	SYS_UTRACE                     = 306 ; int utrace(const char *label, void *addr, size_t len);
	SYS_GETCONTEXT                 = 307 ; int getcontext(struct __ucontext *ucp);
	SYS_SETCONTEXT                 = 308 ; int setcontext(const struct __ucontext *ucp);
	SYS__LWP_CREATE                = 309 ; int _lwp_create(const struct __ucontext *ucp, u_long flags, lwpid_t *new_lwp);
	SYS__LWP_EXIT                  = 310 ; int _lwp_exit(void);
	SYS__LWP_SELF                  = 311 ; lwpid_t _lwp_self(void);
	SYS__LWP_WAIT                  = 312 ; int _lwp_wait(lwpid_t wait_for, lwpid_t *departed);
	SYS__LWP_SUSPEND               = 313 ; int _lwp_suspend(lwpid_t target);
	SYS__LWP_CONTINUE              = 314 ; int _lwp_continue(lwpid_t target);
	SYS__LWP_WAKEUP                = 315 ; int _lwp_wakeup(lwpid_t target);
	SYS__LWP_GETPRIVATE            = 316 ; void * _lwp_getprivate(void);
	SYS__LWP_SETPRIVATE            = 317 ; void _lwp_setprivate(void *ptr);
	SYS__LWP_KILL                  = 318 ; int _lwp_kill(lwpid_t target, int signo);
	SYS__LWP_DETACH                = 319 ; int _lwp_detach(lwpid_t target);
if defined COMPAT_50
	SYS__LWP_PARK                  = 320 ; int _lwp_park(const struct timespec50 *ts, lwpid_t unpark, const void *hint, const void *unparkhint);
end if
	SYS__LWP_UNPARK                = 321 ; int _lwp_unpark(lwpid_t target, const void *hint);
	SYS__LWP_UNPARK_ALL            = 322 ; ssize_t _lwp_unpark_all(const lwpid_t *targets, size_t ntargets, const void *hint);
	SYS__LWP_SETNAME               = 323 ; int _lwp_setname(lwpid_t target, const char *name);
	SYS__LWP_GETNAME               = 324 ; int _lwp_getname(lwpid_t target, char *name, size_t len);
	SYS__LWP_CTL                   = 325 ; int _lwp_ctl(int features, struct lwpctl **address);
; Syscalls 326-339 reserved for LWP syscalls.
	;326	UNIMPL
	;327	UNIMPL
	;328	UNIMPL
	;329	UNIMPL
; SA system calls.
	SYS_SA_REGISTER                = 330 ; int sa_register(sa_upcall_t new, sa_upcall_t *old, int flags, ssize_t stackinfo_offset);
	SYS_SA_STACKS                  = 331 ; int sa_stacks(int num, stack_t *stacks);
	SYS_SA_ENABLE                  = 332 ; int sa_enable(void);
	SYS_SA_SETCONCURRENCY          = 333 ; int sa_setconcurrency(int concurrency);
	SYS_SA_YIELD                   = 334 ; int sa_yield(void);
	SYS_SA_PREEMPT                 = 335 ; int sa_preempt(int sa_id);
	;SYS_SA_UNBLOCKYIELD           = 336 ; OBSOL
;
; Syscalls 337-339 are reserved for other scheduler activation syscalls.
;
	;337	UNIMPL
	;338	UNIMPL
	;339	UNIMPL
	SYS___SIGACTION_SIGTRAMP       = 340 ; int __sigaction_sigtramp(int signum, const struct sigaction *nsa, struct sigaction *osa, const void *tramp, int vers);
	SYS_PMC_GET_INFO               = 341 ; int pmc_get_info(int ctr, int op, void *args);
	SYS_PMC_CONTROL                = 342 ; int pmc_control(int ctr, int op, void *args);
	SYS_RASCTL                     = 343 ; int rasctl(void *addr, size_t len, int op);
	SYS_KQUEUE                     = 344 ; int kqueue(void);
if defined COMPAT_50
	SYS_KEVENT                     = 345 ; int kevent(int fd, const struct kevent *changelist, size_t nchanges, struct kevent *eventlist, size_t nevents, const struct timespec50 *timeout);

; Scheduling system calls.
end if
	SYS__SCHED_SETPARAM            = 346 ; int _sched_setparam(pid_t pid, lwpid_t lid, int policy, const struct sched_param *params);
	SYS__SCHED_GETPARAM            = 347 ; int _sched_getparam(pid_t pid, lwpid_t lid, int *policy, struct sched_param *params);
	SYS__SCHED_SETAFFINITY         = 348 ; int _sched_setaffinity(pid_t pid, lwpid_t lid, size_t size, const cpuset_t *cpuset);
	SYS__SCHED_GETAFFINITY         = 349 ; int _sched_getaffinity(pid_t pid, lwpid_t lid, size_t size, cpuset_t *cpuset);
	SYS_SCHED_YIELD                = 350 ; int sched_yield(void);
	;351	UNIMPL
	;352	UNIMPL
	;353	UNIMPL

	SYS_FSYNC_RANGE                = 354 ; int fsync_range(int fd, int flags, off_t start, off_t length);
	SYS_UUIDGEN                    = 355 ; int uuidgen(struct uuid *store, int count);
	SYS_GETVFSSTAT                 = 356 ; int getvfsstat(struct statvfs *buf, size_t bufsize, int flags);
	SYS_STATVFS1                   = 357 ; int statvfs1(const char *path, struct statvfs *buf, int flags);
	SYS_FSTATVFS1                  = 358 ; int fstatvfs1(int fd, struct statvfs *buf, int flags);
if defined COMPAT_30
	SYS_FHSTATVFS1                 = 359 ; int fhstatvfs1(const struct compat_30_fhandle *fhp, struct statvfs *buf, int flags);
end if
	SYS_EXTATTRCTL                 = 360 ; int extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname);
	SYS_EXTATTR_SET_FILE           = 361 ; int extattr_set_file(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes);
	SYS_EXTATTR_GET_FILE           = 362 ; ssize_t extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_FILE        = 363 ; int extattr_delete_file(const char *path, int attrnamespace, const char *attrname);
	SYS_EXTATTR_SET_FD             = 364 ; int extattr_set_fd(int fd, int attrnamespace, const char *attrname, const void *data, size_t nbytes);
	SYS_EXTATTR_GET_FD             = 365 ; ssize_t extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_FD          = 366 ; int extattr_delete_fd(int fd, int attrnamespace, const char *attrname);
	SYS_EXTATTR_SET_LINK           = 367 ; int extattr_set_link(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes);
	SYS_EXTATTR_GET_LINK           = 368 ; ssize_t extattr_get_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes);
	SYS_EXTATTR_DELETE_LINK        = 369 ; int extattr_delete_link(const char *path, int attrnamespace, const char *attrname);
	SYS_EXTATTR_LIST_FD            = 370 ; ssize_t extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes);
	SYS_EXTATTR_LIST_FILE          = 371 ; ssize_t extattr_list_file(const char *path, int attrnamespace, void *data, size_t nbytes);
	SYS_EXTATTR_LIST_LINK          = 372 ; ssize_t extattr_list_link(const char *path, int attrnamespace, void *data, size_t nbytes);
if defined COMPAT_50
	SYS_PSELECT                    = 373 ; int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec50 *ts, const sigset_t *mask);
	SYS_POLLTS                     = 374 ; int pollts(struct pollfd *fds, u_int nfds, const struct timespec50 *ts, const sigset_t *mask);
end if
	SYS_SETXATTR                   = 375 ; int setxattr(const char *path, const char *name, void *value, size_t size, int flags);
	SYS_LSETXATTR                  = 376 ; int lsetxattr(const char *path, const char *name, void *value, size_t size, int flags);
	SYS_FSETXATTR                  = 377 ; int fsetxattr(int fd, const char *name, void *value, size_t size, int flags);
	SYS_GETXATTR                   = 378 ; int getxattr(const char *path, const char *name, void *value, size_t size);
	SYS_LGETXATTR                  = 379 ; int lgetxattr(const char *path, const char *name, void *value, size_t size);
	SYS_FGETXATTR                  = 380 ; int fgetxattr(int fd, const char *name, void *value, size_t size);
	SYS_LISTXATTR                  = 381 ; int listxattr(const char *path, char *list, size_t size);
	SYS_LLISTXATTR                 = 382 ; int llistxattr(const char *path, char *list, size_t size);
	SYS_FLISTXATTR                 = 383 ; int flistxattr(int fd, char *list, size_t size);
	SYS_REMOVEXATTR                = 384 ; int removexattr(const char *path, const char *name);
	SYS_LREMOVEXATTR               = 385 ; int lremovexattr(const char *path, const char *name);
	SYS_FREMOVEXATTR               = 386 ; int fremovexattr(int fd, const char *name);
if defined COMPAT_50
	SYS_STAT                       = 387 ; int stat(const char *path, struct stat30 *ub);
	SYS_FSTAT                      = 388 ; int fstat(int fd, struct stat30 *sb);
	SYS_LSTAT                      = 389 ; int lstat(const char *path, struct stat30 *ub);
end if
	SYS_GETDENTS                   = 390 ; int getdents(int fd, char *buf, size_t count);
	;SYS_OLD_POSIX_FADVISE         = 391 ; IGNORED
if defined COMPAT_30
	SYS_FHSTAT                     = 392 ; int fhstat(const struct compat_30_fhandle *fhp, struct stat30 *sb);
end if
if defined COMPAT_50
	SYS_NTP_GETTIME                = 393 ; int ntp_gettime(struct ntptimeval50 *ntvp);
end if
	SYS_SOCKET                     = 394 ; int socket(int domain, int type, int protocol);
	SYS_GETFH                      = 395 ; int getfh(const char *fname, void *fhp, size_t *fh_size);
	SYS_FHOPEN                     = 396 ; int fhopen(const void *fhp, size_t fh_size,int flags);
	SYS_FHSTATVFS1                 = 397 ; int fhstatvfs1(const void *fhp, size_t fh_size, struct statvfs *buf, int flags);
if defined COMPAT_50
	SYS_FHSTAT                     = 398 ; int fhstat(const void *fhp, size_t fh_size, struct stat30 *sb);

; Asynchronous I/O system calls
end if
	SYS_AIO_CANCEL                 = 399 ; int aio_cancel(int fildes, struct aiocb *aiocbp);
	SYS_AIO_ERROR                  = 400 ; int aio_error(const struct aiocb *aiocbp);
	SYS_AIO_FSYNC                  = 401 ; int aio_fsync(int op, struct aiocb *aiocbp);
	SYS_AIO_READ                   = 402 ; int aio_read(struct aiocb *aiocbp);
	SYS_AIO_RETURN                 = 403 ; int aio_return(struct aiocb *aiocbp);
if defined COMPAT_50
	SYS_AIO_SUSPEND                = 404 ; int aio_suspend(const struct aiocb *const *list, int nent, const struct timespec50 *timeout);
end if
	SYS_AIO_WRITE                  = 405 ; int aio_write(struct aiocb *aiocbp);
	SYS_LIO_LISTIO                 = 406 ; int lio_listio(int mode, struct aiocb *const *list, int nent, struct sigevent *sig);

	;407	UNIMPL
	;408	UNIMPL
	;409	UNIMPL

	SYS_MOUNT                      = 410 ; int mount(const char *type, const char *path, int flags, void *data, size_t data_len);
	SYS_MREMAP                     = 411 ; void * mremap(void *old_address, size_t old_size, void *new_address, size_t new_size, int flags);

; Processor-sets system calls
	SYS_PSET_CREATE                = 412 ; int pset_create(psetid_t *psid);
	SYS_PSET_DESTROY               = 413 ; int pset_destroy(psetid_t psid);
	SYS_PSET_ASSIGN                = 414 ; int pset_assign(psetid_t psid, cpuid_t cpuid, psetid_t *opsid);
	SYS__PSET_BIND                 = 415 ; int _pset_bind(idtype_t idtype, id_t first_id, id_t second_id, psetid_t psid, psetid_t *opsid);
	SYS_POSIX_FADVISE              = 416 ; int posix_fadvise(int fd, int PAD, off_t offset, off_t len, int advice);
	SYS_SELECT                     = 417 ; int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv);
	SYS_GETTIMEOFDAY               = 418 ; int gettimeofday(struct timeval *tp, void *tzp);
	SYS_SETTIMEOFDAY               = 419 ; int settimeofday(const struct timeval *tv, const void *tzp);
	SYS_UTIMES                     = 420 ; int utimes(const char *path, const struct timeval *tptr);
	SYS_ADJTIME                    = 421 ; int adjtime(const struct timeval *delta, struct timeval *olddelta);
	SYS_LFS_SEGWAIT                = 422 ; int lfs_segwait(fsid_t *fsidp, struct timeval *tv);
	SYS_FUTIMES                    = 423 ; int futimes(int fd, const struct timeval *tptr);
	SYS_LUTIMES                    = 424 ; int lutimes(const char *path, const struct timeval *tptr);
	SYS_SETITIMER                  = 425 ; int setitimer(int which, const struct itimerval *itv, struct itimerval *oitv);
	SYS_GETITIMER                  = 426 ; int getitimer(int which, struct itimerval *itv);
	SYS_CLOCK_GETTIME              = 427 ; int clock_gettime(clockid_t clock_id, struct timespec *tp);
	SYS_CLOCK_SETTIME              = 428 ; int clock_settime(clockid_t clock_id, const struct timespec *tp);
	SYS_CLOCK_GETRES               = 429 ; int clock_getres(clockid_t clock_id, struct timespec *tp);
	SYS_NANOSLEEP                  = 430 ; int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
	SYS___SIGTIMEDWAIT             = 431 ; int __sigtimedwait(const sigset_t *set, siginfo_t *info, struct timespec *timeout);
	SYS_MQ_TIMEDSEND               = 432 ; int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout);
	SYS_MQ_TIMEDRECEIVE            = 433 ; ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec *abs_timeout);
	SYS__LWP_PARK                  = 434 ; int _lwp_park(const struct timespec *ts, lwpid_t unpark, const void *hint, const void *unparkhint);
	SYS_KEVENT                     = 435 ; int kevent(int fd, const struct kevent *changelist, size_t nchanges, struct kevent *eventlist, size_t nevents, const struct timespec *timeout);
	SYS_PSELECT                    = 436 ; int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask);
	SYS_POLLTS                     = 437 ; int pollts(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask);
	SYS_AIO_SUSPEND                = 438 ; int aio_suspend( const struct aiocb *const *list, int nent, const struct timespec *timeout);
	SYS_STAT                       = 439 ; int stat(const char *path, struct stat *ub);
	SYS_FSTAT                      = 440 ; int fstat(int fd, struct stat *sb);
	SYS_LSTAT                      = 441 ; int lstat(const char *path, struct stat *ub);
; #if defined(SYSVSEM) || !defined(_KERNEL_OPT)
	SYS___SEMCTL                   = 442 ; int __semctl(int semid, int semnum, int cmd, ... union __semun *arg);
; #else
	;SYS_____SEMCTL50              = 442 ; EXCL
; #endif
; #if defined(SYSVSHM) || !defined(_KERNEL_OPT)
	SYS_SHMCTL                     = 443 ; int shmctl(int shmid, int cmd, struct shmid_ds *buf);
; #else
	;SYS_____SHMCTL50              = 443 ; EXCL
; #endif
; #if defined(SYSVMSG) || !defined(_KERNEL_OPT)
	SYS_MSGCTL                     = 444 ; int msgctl(int msqid, int cmd, struct msqid_ds *buf);
; #else
	;SYS_____MSGCTL50              = 444 ; EXCL
; #endif
	SYS_GETRUSAGE                  = 445 ; int getrusage(int who, struct rusage *rusage);
	SYS_TIMER_SETTIME              = 446 ; int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
	SYS_TIMER_GETTIME              = 447 ; int timer_gettime(timer_t timerid, struct itimerspec *value);
; #if defined(NTP) || !defined(_KERNEL_OPT)
	SYS_NTP_GETTIME                = 448 ; int ntp_gettime(struct ntptimeval *ntvp);
; #else
	;SYS____NTP_GETTIME50          = 448 ; EXCL
; #endif
	SYS_WAIT4                      = 449 ; int wait4(int pid, int *status, int options, struct rusage *rusage);
	SYS_MKNOD                      = 450 ; int mknod(const char *path, mode_t mode, dev_t dev);
	SYS_FHSTAT                     = 451 ; int fhstat(const void *fhp, size_t fh_size, struct stat *sb);


;==============================================
; Converted with NetBSD_syscalls4fasm.pl v1.0.1
; https://github.com/graudeejs/asm4BSD/

; vim: set ts=8 sw=8 syn=fasm:
