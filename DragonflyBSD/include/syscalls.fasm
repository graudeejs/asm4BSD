;  $DragonFly: src/sys/kern/syscalls.master,v 1.60 2008/11/10 22:11:45 pavalos Exp $

; @(#)syscalls.master	8.2 (Berkeley) 1/13/94
; $FreeBSD: src/sys/kern/syscalls.master,v 1.72.2.10 2002/07/12 08:22:46 alfred Exp $
;
; System call name/number master file.
; Processed to created init_sysent.c, syscalls.c and syscall.h.

; Columns: number [MPSAFE] type nargs namespc name alt{name,tag,rtyp}/comments
;	number	system call number, must be in order
;   MPSAFE	optional field, specifies that syscall does not want the
;		BGL grabbed automatically (it is SMP safe).
;	type	one of STD, OBSOL, UNIMPL, COMPAT, CPT_NOA, LIBCOMPAT,
;		NODEF, NOARGS, NOPROTO, NOIMPL
;	namespc one of POSIX, BSD, NOHIDE
;	name	psuedo-prototype of syscall routine
;		If one of the following alts is different, then all appear:
;	altname	name of system call if different
;	alttag	name of args struct tag if different from [o]`name'"_args"
;	altrtyp	return type if not int (bogus - syscalls always return int)
;		for UNIMPL/OBSOL, name continues with comments

; types:
;	STD	always included
;	COMPAT	included on COMPAT #ifdef
;	LIBCOMPAT included on COMPAT #ifdef, and placed in syscall.h
;	OBSOL	obsolete, not included in system, only specifies name
;	UNIMPL	not implemented, placeholder only

; #ifdef's, etc. may be included, and are copied to the output files.

; #include <sys/param.h>
; #include <sys/sysent.h>
; #include <sys/sysproto.h>
; #include <sys/statvfs.h>

; #ifdef COMPAT_43
; #include <emulation/43bsd/stat.h>
; #endif

; #include <emulation/dragonfly12/stat.h>

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

	;SYS_NOSYS                     = 0 ; int nosys(void);
	SYS_EXIT                       = 1 ; void exit(int rval);
	SYS_FORK                       = 2 ; int fork(void);
	SYS_READ                       = 3 ; ssize_t read(int fd, void *buf, size_t nbyte);
	SYS_WRITE                      = 4 ; ssize_t write(int fd, const void *buf, size_t nbyte);
	SYS_OPEN                       = 5 ; int open(char *path, int flags, int mode);
; XXX should be		{ int open(const char *path, int flags, ...); }
; but we're not ready for `const' or varargs.
; XXX man page says `mode_t mode'.
	SYS_CLOSE                      = 6 ; int close(int fd);
	SYS_WAIT4                      = 7 ; int wait4(int pid, int *status, int options, struct rusage *rusage);
if defined COMPAT
	SYS_CREAT                      = 8 ; int creat(char *path, int mode);
end if
	SYS_LINK                       = 9 ; int link(char *path, char *link);
	SYS_UNLINK                     = 10 ; int unlink(char *path);
	;SYS_EXECV                     = 11 ; NOHIDE
	SYS_CHDIR                      = 12 ; int chdir(char *path);
	SYS_FCHDIR                     = 13 ; int fchdir(int fd);
	SYS_MKNOD                      = 14 ; int mknod(char *path, int mode, int dev);
	SYS_CHMOD                      = 15 ; int chmod(char *path, int mode);
	SYS_CHOWN                      = 16 ; int chown(char *path, int uid, int gid);
	SYS_OBREAK                     = 17 ; int obreak(char *nsize);
	SYS_GETFSSTAT                  = 18 ; int getfsstat(struct statfs *buf, long bufsize, int flags);
if defined COMPAT
	SYS_LSEEK                      = 19 ; long lseek(int fd, long offset, int whence);
end if
	SYS_GETPID                     = 20 ; pid_t getpid(void);
	SYS_MOUNT                      = 21 ; int mount(char *type, char *path, int flags, caddr_t data);
; XXX `path' should have type `const char *' but we're not ready for that.
	SYS_UNMOUNT                    = 22 ; int unmount(char *path, int flags);
	SYS_SETUID                     = 23 ; int setuid(uid_t uid);
	SYS_GETUID                     = 24 ; uid_t getuid(void);
	SYS_GETEUID                    = 25 ; uid_t geteuid(void);
	SYS_PTRACE                     = 26 ; int ptrace(int req, pid_t pid, caddr_t addr, int data);
	SYS_RECVMSG                    = 27 ; int recvmsg(int s, struct msghdr *msg, int flags);
	SYS_SENDMSG                    = 28 ; int sendmsg(int s, caddr_t msg, int flags);
	SYS_RECVFROM                   = 29 ; int recvfrom(int s, caddr_t buf, size_t len, int flags, caddr_t from, int *fromlenaddr);
	SYS_ACCEPT                     = 30 ; int accept(int s, caddr_t name, int *anamelen);
	SYS_GETPEERNAME                = 31 ; int getpeername(int fdes, caddr_t asa, int *alen);
	SYS_GETSOCKNAME                = 32 ; int getsockname(int fdes, caddr_t asa, int *alen);
	SYS_ACCESS                     = 33 ; int access(char *path, int flags);
	SYS_CHFLAGS                    = 34 ; int chflags(char *path, int flags);
	SYS_FCHFLAGS                   = 35 ; int fchflags(int fd, int flags);
	SYS_SYNC                       = 36 ; int sync(void);
	SYS_KILL                       = 37 ; int kill(int pid, int signum);
if defined COMPAT
	SYS_STAT                       = 38 ; int stat(char *path, struct ostat *ub);
end if
	SYS_GETPPID                    = 39 ; pid_t getppid(void);
if defined COMPAT
	SYS_LSTAT                      = 40 ; int lstat(char *path, struct ostat *ub);
end if
	SYS_DUP                        = 41 ; int dup(u_int fd);
	SYS_PIPE                       = 42 ; int pipe(void);
	SYS_GETEGID                    = 43 ; gid_t getegid(void);
	SYS_PROFIL                     = 44 ; int profil(caddr_t samples, size_t size, size_t offset, u_int scale);
	SYS_KTRACE                     = 45 ; int ktrace(const char *fname, int ops, int facs, int pid);
	;SYS_FREEBSD3_SIGACTION        = 46 ; NOHIDE
	SYS_GETGID                     = 47 ; gid_t getgid(void);
	;SYS_FREEBSD3_SIGPROCMASK      = 48 ; NOHIDE
; XXX note nonstandard (bogus) calling convention - the libc stub passes
; us the mask, not a pointer to it, and we return the old mask as the
; (int) return value.
	SYS_GETLOGIN                   = 49 ; int getlogin(char *namebuf, u_int namelen);
	SYS_SETLOGIN                   = 50 ; int setlogin(char *namebuf);
	SYS_ACCT                       = 51 ; int acct(char *path);
	;SYS_FREEBSD3_SIGPENDING       = 52 ; NOHIDE
	SYS_SIGALTSTACK                = 53 ; int sigaltstack(stack_t *ss, stack_t *oss);
	SYS_IOCTL                      = 54 ; int ioctl(int fd, u_long com, caddr_t data);
	SYS_REBOOT                     = 55 ; int reboot(int opt);
	SYS_REVOKE                     = 56 ; int revoke(char *path);
	SYS_SYMLINK                    = 57 ; int symlink(char *path, char *link);
	SYS_READLINK                   = 58 ; int readlink(char *path, char *buf, int count);
	SYS_EXECVE                     = 59 ; int execve(char *fname, char **argv, char **envv);
	SYS_UMASK                      = 60 ; int umask(int newmask);
	SYS_CHROOT                     = 61 ; int chroot(char *path);
if defined COMPAT
	SYS_FSTAT                      = 62 ; int fstat(int fd, struct ostat *sb);
	SYS_GETKERNINFO                = 63 ; int getkerninfo(int op, char *where, size_t *size, int arg);
	SYS_GETPAGESIZE                = 64 ; int getpagesize(void);
end if
	SYS_MSYNC                      = 65 ; int msync(void *addr, size_t len, int flags);
	SYS_VFORK                      = 66 ; int vfork(void);
	;SYS_VREAD                     = 67 ; NOHIDE
	;SYS_VWRITE                    = 68 ; NOHIDE
	SYS_SBRK                       = 69 ; int sbrk(int incr);
	SYS_SSTK                       = 70 ; int sstk(int incr);
if defined COMPAT
	SYS_MMAP                       = 71 ; int mmap(void *addr, int len, int prot, int flags, int fd, long pos);
end if
	SYS_OVADVISE                   = 72 ; int ovadvise(int anom);
	SYS_MUNMAP                     = 73 ; int munmap(void *addr, size_t len);
	SYS_MPROTECT                   = 74 ; int mprotect(const void *addr, size_t len, int prot);
	SYS_MADVISE                    = 75 ; int madvise(void *addr, size_t len, int behav);
	;SYS_VHANGUP                   = 76 ; NOHIDE
	;SYS_VLIMIT                    = 77 ; NOHIDE
	SYS_MINCORE                    = 78 ; int mincore(const void *addr, size_t len, char *vec);
	SYS_GETGROUPS                  = 79 ; int getgroups(u_int gidsetsize, gid_t *gidset);
	SYS_SETGROUPS                  = 80 ; int setgroups(u_int gidsetsize, gid_t *gidset);
	SYS_GETPGRP                    = 81 ; int getpgrp(void);
	SYS_SETPGID                    = 82 ; int setpgid(int pid, int pgid);
	SYS_SETITIMER                  = 83 ; int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv);
if defined COMPAT
	SYS_WAIT                       = 84 ; int wait(void);
end if
	SYS_SWAPON                     = 85 ; int swapon(char *name);
	SYS_GETITIMER                  = 86 ; int getitimer(u_int which, struct itimerval *itv);
if defined COMPAT
	SYS_GETHOSTNAME                = 87 ; int gethostname(char *hostname, u_int len);
	SYS_SETHOSTNAME                = 88 ; int sethostname(char *hostname, u_int len);
end if
	SYS_GETDTABLESIZE              = 89 ; int getdtablesize(void);
	SYS_DUP2                       = 90 ; int dup2(u_int from, u_int to);
	;SYS_GETDOPT                   = 91 ; BSD
	SYS_FCNTL                      = 92 ; int fcntl(int fd, int cmd, long arg);
; XXX should be		{ int fcntl(int fd, int cmd, ...); }
; but we're not ready for varargs.
; XXX man page says `int arg' too.
	SYS_SELECT                     = 93 ; int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv);
	;SYS_SETDOPT                   = 94 ; BSD
	SYS_FSYNC                      = 95 ; int fsync(int fd);
	SYS_SETPRIORITY                = 96 ; int setpriority(int which, int who, int prio);
	SYS_SOCKET                     = 97 ; int socket(int domain, int type, int protocol);
	SYS_CONNECT                    = 98 ; int connect(int s, caddr_t name, int namelen);
	SYS_ACCEPT                     = 99 ; int accept(int s, caddr_t name, int *anamelen);
	SYS_GETPRIORITY                = 100 ; int getpriority(int which, int who);
if defined COMPAT
	SYS_SEND                       = 101 ; int send(int s, caddr_t buf, int len, int flags);
	SYS_RECV                       = 102 ; int recv(int s, caddr_t buf, int len, int flags);
end if
	;SYS_FREEBSD3_SIGRETURN        = 103 ; NOHIDE
	SYS_BIND                       = 104 ; int bind(int s, caddr_t name, int namelen);
	SYS_SETSOCKOPT                 = 105 ; int setsockopt(int s, int level, int name, caddr_t val, int valsize);
	SYS_LISTEN                     = 106 ; int listen(int s, int backlog);
	;SYS_VTIMES                    = 107 ; NOHIDE
if defined COMPAT
	SYS_SIGVEC                     = 108 ; int sigvec(int signum, struct sigvec *nsv, struct sigvec *osv);
	SYS_SIGBLOCK                   = 109 ; int sigblock(int mask);
	SYS_SIGSETMASK                 = 110 ; int sigsetmask(int mask);
end if
	;SYS_FREEBSD3_SIGSUSPEND       = 111 ; NOHIDE
; XXX note nonstandard (bogus) calling convention - the libc stub passes
; us the mask, not a pointer to it.
if defined COMPAT
	SYS_SIGSTACK                   = 112 ; int sigstack(struct sigstack *nss, struct sigstack *oss);
	SYS_RECVMSG                    = 113 ; int recvmsg(int s, struct omsghdr *msg, int flags);
	SYS_SENDMSG                    = 114 ; int sendmsg(int s, caddr_t msg, int flags);
end if
	;SYS_VTRACE                    = 115 ; NOHIDE
	SYS_GETTIMEOFDAY               = 116 ; int gettimeofday(struct timeval *tp, struct timezone *tzp);
	SYS_GETRUSAGE                  = 117 ; int getrusage(int who, struct rusage *rusage);
	SYS_GETSOCKOPT                 = 118 ; int getsockopt(int s, int level, int name, caddr_t val, int *avalsize);
	;SYS_RESUBA                    = 119 ; NOHIDE
	SYS_READV                      = 120 ; int readv(int fd, struct iovec *iovp, u_int iovcnt);
	SYS_WRITEV                     = 121 ; int writev(int fd, struct iovec *iovp, u_int iovcnt);
	SYS_SETTIMEOFDAY               = 122 ; int settimeofday(struct timeval *tv, struct timezone *tzp);
	SYS_FCHOWN                     = 123 ; int fchown(int fd, int uid, int gid);
	SYS_FCHMOD                     = 124 ; int fchmod(int fd, int mode);
	SYS_RECVFROM                   = 125 ; int recvfrom(int s, caddr_t buf, size_t len, int flags, caddr_t from, int *fromlenaddr);
	SYS_SETREUID                   = 126 ; int setreuid(int ruid, int euid);
	SYS_SETREGID                   = 127 ; int setregid(int rgid, int egid);
	SYS_RENAME                     = 128 ; int rename(char *from, char *to);
if defined COMPAT
	SYS_TRUNCATE                   = 129 ; int truncate(char *path, long length);
	SYS_FTRUNCATE                  = 130 ; int ftruncate(int fd, long length);
end if
	SYS_FLOCK                      = 131 ; int flock(int fd, int how);
	SYS_MKFIFO                     = 132 ; int mkfifo(char *path, int mode);
	SYS_SENDTO                     = 133 ; int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, int tolen);
	SYS_SHUTDOWN                   = 134 ; int shutdown(int s, int how);
	SYS_SOCKETPAIR                 = 135 ; int socketpair(int domain, int type, int protocol, int *rsv);
	SYS_MKDIR                      = 136 ; int mkdir(char *path, int mode);
	SYS_RMDIR                      = 137 ; int rmdir(char *path);
	SYS_UTIMES                     = 138 ; int utimes(char *path, struct timeval *tptr);
	;SYS_4                         = 139 ; NOHIDE
	SYS_ADJTIME                    = 140 ; int adjtime(struct timeval *delta, struct timeval *olddelta);
if defined COMPAT
	SYS_GETPEERNAME                = 141 ; int getpeername(int fdes, caddr_t asa, int *alen);
	SYS_GETHOSTID                  = 142 ; long gethostid(void);
	SYS_SETHOSTID                  = 143 ; int sethostid(long hostid);
	SYS_GETRLIMIT                  = 144 ; int getrlimit(u_int which, struct orlimit *rlp);
	SYS_SETRLIMIT                  = 145 ; int setrlimit(u_int which, struct orlimit *rlp);
	SYS_KILLPG                     = 146 ; int killpg(int pgid, int signum);
end if
	SYS_SETSID                     = 147 ; int setsid(void);
	SYS_QUOTACTL                   = 148 ; int quotactl(char *path, int cmd, int uid, caddr_t arg);
if defined COMPAT
	SYS_QUOTA                      = 149 ; int quota(void);
end if
	SYS_GETSOCKNAME                = 150 ; int getsockname(int fdec, caddr_t asa, int *alen);

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
	;SYS_SEM_LOCK                  = 151 ; NOHIDE
	;SYS_SEM_WAKEUP                = 152 ; NOHIDE
	;SYS_ASYNCDAEMON               = 153 ; NOHIDE
	;SYS_NOSYS                     = 154 ; NOHIDE
; 155 is initialized by the NFS code, if present.
	SYS_NFSSVC                     = 155 ; int nfssvc(int flag, caddr_t argp);
if defined COMPAT
	SYS_GETDIRENTRIES              = 156 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
end if
	SYS_STATFS                     = 157 ; int statfs(char *path, struct statfs *buf);
	SYS_FSTATFS                    = 158 ; int fstatfs(int fd, struct statfs *buf);
	;SYS_NOSYS                     = 159 ; NOHIDE
	;SYS_NOSYS                     = 160 ; NOHIDE
; 161 is initialized by the NFS code, if present.
	SYS_GETFH                      = 161 ; int getfh(char *fname, struct fhandle *fhp);
	SYS_GETDOMAINNAME              = 162 ; int getdomainname(char *domainname, int len);
	SYS_SETDOMAINNAME              = 163 ; int setdomainname(char *domainname, int len);
	SYS_UNAME                      = 164 ; int uname(struct utsname *name);
	SYS_SYSARCH                    = 165 ; int sysarch(int op, char *parms);
	SYS_RTPRIO                     = 166 ; int rtprio(int function, pid_t pid, struct rtprio *rtp);
	;SYS_NOSYS                     = 167 ; NOHIDE
	;SYS_NOSYS                     = 168 ; NOHIDE
	SYS_SEMSYS                     = 169 ; int semsys(int which, int a2, int a3, int a4, int a5);
; XXX should be		{ int semsys(int which, ...); }
	SYS_MSGSYS                     = 170 ; int msgsys(int which, int a2, int a3, int a4, int a5, int a6);
; XXX should be		{ int msgsys(int which, ...); }
	SYS_SHMSYS                     = 171 ; int shmsys(int which, int a2, int a3, int a4);
; XXX should be		{ int shmsys(int which, ...); }
	;SYS_NOSYS                     = 172 ; NOHIDE
	SYS_EXTPREAD                   = 173 ; ssize_t extpread(int fd, void *buf, size_t nbyte, int flags, off_t offset);
	SYS_EXTPWRITE                  = 174 ; ssize_t extpwrite(int fd, const void *buf, size_t nbyte, int flags, off_t offset);
	;SYS_NOSYS                     = 175 ; NOHIDE
	SYS_NTP_ADJTIME                = 176 ; int ntp_adjtime(struct timex *tp);
	;SYS_SFORK                     = 177 ; NOHIDE
	;SYS_GETDESCRIPTOR             = 178 ; NOHIDE
	;SYS_SETDESCRIPTOR             = 179 ; NOHIDE
	;SYS_NOSYS                     = 180 ; NOHIDE

; Syscalls 181-199 are used by/reserved for BSD
	SYS_SETGID                     = 181 ; int setgid(gid_t gid);
	SYS_SETEGID                    = 182 ; int setegid(gid_t egid);
	SYS_SETEUID                    = 183 ; int seteuid(uid_t euid);
	;SYS_LFS_BMAPV                 = 184 ; BSD
	;SYS_LFS_MARKV                 = 185 ; BSD
	;SYS_LFS_SEGCLEAN              = 186 ; BSD
	;SYS_LFS_SEGWAIT               = 187 ; BSD
if defined COMPAT
	SYS_STAT                       = 188 ; int stat(const char *path, struct dfbsd12_stat *ub);
	SYS_FSTAT                      = 189 ; int fstat(int fd, struct dfbsd12_stat *sb);
	SYS_LSTAT                      = 190 ; int lstat(const char *path, struct dfbsd12_stat *ub);
end if
	SYS_PATHCONF                   = 191 ; int pathconf(char *path, int name);
	SYS_FPATHCONF                  = 192 ; int fpathconf(int fd, int name);
	;SYS_NOSYS                     = 193 ; NOHIDE
	SYS_GETRLIMIT                  = 194 ; int getrlimit(u_int which, struct rlimit *rlp);
	SYS_SETRLIMIT                  = 195 ; int setrlimit(u_int which, struct rlimit *rlp);
if defined COMPAT
	SYS_GETDIRENTRIES              = 196 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
end if
	SYS_MMAP                       = 197 ; caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, int pad, off_t pos);
	;SYS_NOSYS                     = 198 ; int nosys(void);
	SYS_LSEEK                      = 199 ; off_t lseek(int fd, int pad, off_t offset, int whence);
	SYS_TRUNCATE                   = 200 ; int truncate(char *path, int pad, off_t length);
	SYS_FTRUNCATE                  = 201 ; int ftruncate(int fd, int pad, off_t length);
	SYS___SYSCTL                   = 202 ; int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen);
; properly, __sysctl should be a NOHIDE, but making an exception
; here allows to avoid one in libc/sys/Makefile.inc.
	SYS_MLOCK                      = 203 ; int mlock(const void *addr, size_t len);
	SYS_MUNLOCK                    = 204 ; int munlock(const void *addr, size_t len);
	SYS_UNDELETE                   = 205 ; int undelete(char *path);
	SYS_FUTIMES                    = 206 ; int futimes(int fd, struct timeval *tptr);
	SYS_GETPGID                    = 207 ; int getpgid(pid_t pid);
	;SYS_NEWREBOOT                 = 208 ; NOHIDE
	SYS_POLL                       = 209 ; int poll(struct pollfd *fds, u_int nfds, int timeout);

;
; The following are reserved for loadable syscalls
;
; 210 is used by the Checkpoint Module
	;SYS_LKMNOSYS                  = 210 ; NOHIDE
	;SYS_LKMNOSYS                  = 211 ; NOHIDE
	;SYS_LKMNOSYS                  = 212 ; NOHIDE
	;SYS_LKMNOSYS                  = 213 ; NOHIDE
	;SYS_LKMNOSYS                  = 214 ; NOHIDE
	;SYS_LKMNOSYS                  = 215 ; NOHIDE
	;SYS_LKMNOSYS                  = 216 ; NOHIDE
	;SYS_LKMNOSYS                  = 217 ; NOHIDE
	;SYS_LKMNOSYS                  = 218 ; NOHIDE
	;SYS_LKMNOSYS                  = 219 ; NOHIDE

;
; The following were introduced with NetBSD/4.4Lite-2
;
	SYS___SEMCTL                   = 220 ; int __semctl(int semid, int semnum, int cmd, union semun *arg);
	SYS_SEMGET                     = 221 ; int semget(key_t key, int nsems, int semflg);
	SYS_SEMOP                      = 222 ; int semop(int semid, struct sembuf *sops, u_int nsops);
	;SYS_SEMCONFIG                 = 223 ; NOHIDE
	SYS_MSGCTL                     = 224 ; int msgctl(int msqid, int cmd, struct msqid_ds *buf);
	SYS_MSGGET                     = 225 ; int msgget(key_t key, int msgflg);
	SYS_MSGSND                     = 226 ; int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg);
	SYS_MSGRCV                     = 227 ; int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
	SYS_SHMAT                      = 228 ; int shmat(int shmid, void *shmaddr, int shmflg);
	SYS_SHMCTL                     = 229 ; int shmctl(int shmid, int cmd, struct shmid_ds *buf);
	SYS_SHMDT                      = 230 ; int shmdt(void *shmaddr);
	SYS_SHMGET                     = 231 ; int shmget(key_t key, int size, int shmflg);
;
	SYS_CLOCK_GETTIME              = 232 ; int clock_gettime(clockid_t clock_id, struct timespec *tp);
	SYS_CLOCK_SETTIME              = 233 ; int clock_settime(clockid_t clock_id, const struct timespec *tp);
	SYS_CLOCK_GETRES               = 234 ; int clock_getres(clockid_t clock_id, struct timespec *tp);
	;SYS_TIMER_CREATE              = 235 ; NOHIDE
	;SYS_TIMER_DELETE              = 236 ; NOHIDE
	;SYS_TIMER_SETTIME             = 237 ; NOHIDE
	;SYS_TIMER_GETTIME             = 238 ; NOHIDE
	;SYS_TIMER_GETOVERRUN          = 239 ; NOHIDE
	SYS_NANOSLEEP                  = 240 ; int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
	;SYS_NOSYS                     = 241 ; NOHIDE
	;SYS_NOSYS                     = 242 ; NOHIDE
	;SYS_NOSYS                     = 243 ; NOHIDE
	;SYS_NOSYS                     = 244 ; NOHIDE
	;SYS_NOSYS                     = 245 ; NOHIDE
	;SYS_NOSYS                     = 246 ; NOHIDE
	;SYS_NOSYS                     = 247 ; NOHIDE
	;SYS_NOSYS                     = 248 ; NOHIDE
	;SYS_NOSYS                     = 249 ; NOHIDE
; syscall numbers initially used in OpenBSD
	SYS_MINHERIT                   = 250 ; int minherit(void *addr, size_t len, int inherit);
	SYS_RFORK                      = 251 ; int rfork(int flags);
	SYS_OPENBSD_POLL               = 252 ; int openbsd_poll(struct pollfd *fds, u_int nfds, int timeout);
	SYS_ISSETUGID                  = 253 ; int issetugid(void);
	SYS_LCHOWN                     = 254 ; int lchown(char *path, int uid, int gid);
	;SYS_NOSYS                     = 255 ; NOHIDE
	;SYS_NOSYS                     = 256 ; NOHIDE
	;SYS_NOSYS                     = 257 ; NOHIDE
	;SYS_NOSYS                     = 258 ; NOHIDE
	;SYS_NOSYS                     = 259 ; NOHIDE
	;SYS_NOSYS                     = 260 ; NOHIDE
	;SYS_NOSYS                     = 261 ; NOHIDE
	;SYS_NOSYS                     = 262 ; NOHIDE
	;SYS_NOSYS                     = 263 ; NOHIDE
	;SYS_NOSYS                     = 264 ; NOHIDE
	;SYS_NOSYS                     = 265 ; NOHIDE
	;SYS_NOSYS                     = 266 ; NOHIDE
	;SYS_NOSYS                     = 267 ; NOHIDE
	;SYS_NOSYS                     = 268 ; NOHIDE
	;SYS_NOSYS                     = 269 ; NOHIDE
	;SYS_NOSYS                     = 270 ; NOHIDE
	;SYS_NOSYS                     = 271 ; NOHIDE
if defined COMPAT
	SYS_GETDENTS                   = 272 ; int getdents(int fd, char *buf, size_t count);
end if
	;SYS_NOSYS                     = 273 ; NOHIDE
	SYS_LCHMOD                     = 274 ; int lchmod(char *path, mode_t mode);
	SYS_LCHOWN                     = 275 ; int lchown(char *path, uid_t uid, gid_t gid);
	SYS_LUTIMES                    = 276 ; int lutimes(char *path, struct timeval *tptr);
	SYS_MSYNC                      = 277 ; int msync(void *addr, size_t len, int flags);
	SYS_NSTAT                      = 278 ; int nstat(char *path, struct nstat *ub);
	SYS_NFSTAT                     = 279 ; int nfstat(int fd, struct nstat *sb);
	SYS_NLSTAT                     = 280 ; int nlstat(char *path, struct nstat *ub);
	;SYS_NOSYS                     = 281 ; NOHIDE
	;SYS_NOSYS                     = 282 ; NOHIDE
	;SYS_NOSYS                     = 283 ; NOHIDE
	;SYS_NOSYS                     = 284 ; NOHIDE
	;SYS_NOSYS                     = 285 ; NOHIDE
	;SYS_NOSYS                     = 286 ; NOHIDE
	;SYS_NOSYS                     = 287 ; NOHIDE
	;SYS_NOSYS                     = 288 ; NOHIDE
; 289 and 290 from NetBSD (OpenBSD: 267 and 268)
	SYS_EXTPREADV                  = 289 ; ssize_t extpreadv(int fd, struct iovec *iovp, u_int iovcnt, int flags, off_t offset);
	SYS_EXTPWRITEV                 = 290 ; ssize_t extpwritev(int fd, struct iovec *iovp,u_int iovcnt, int flags, off_t offset);
	;SYS_NOSYS                     = 291 ; NOHIDE
	;SYS_NOSYS                     = 292 ; NOHIDE
	;SYS_NOSYS                     = 293 ; NOHIDE
	;SYS_NOSYS                     = 294 ; NOHIDE
	;SYS_NOSYS                     = 295 ; NOHIDE
	;SYS_NOSYS                     = 296 ; NOHIDE
; XXX 297 is 300 in NetBSD
	SYS_FHSTATFS                   = 297 ; int fhstatfs(const struct fhandle *u_fhp, struct statfs *buf);
	SYS_FHOPEN                     = 298 ; int fhopen(const struct fhandle *u_fhp, int flags);
if defined COMPAT
	SYS_FHSTAT                     = 299 ; int fhstat(const struct fhandle *u_fhp, struct dfbsd12_stat *sb);
; syscall numbers for FreeBSD
end if
	SYS_MODNEXT                    = 300 ; int modnext(int modid);
	SYS_MODSTAT                    = 301 ; int modstat(int modid, struct module_stat* stat);
	SYS_MODFNEXT                   = 302 ; int modfnext(int modid);
	SYS_MODFIND                    = 303 ; int modfind(const char *name);
	SYS_KLDLOAD                    = 304 ; int kldload(const char *file);
	SYS_KLDUNLOAD                  = 305 ; int kldunload(int fileid);
	SYS_KLDFIND                    = 306 ; int kldfind(const char *file);
	SYS_KLDNEXT                    = 307 ; int kldnext(int fileid);
	SYS_KLDSTAT                    = 308 ; int kldstat(int fileid, struct kld_file_stat* stat);
	SYS_KLDFIRSTMOD                = 309 ; int kldfirstmod(int fileid);
	SYS_GETSID                     = 310 ; int getsid(pid_t pid);
	SYS_SETRESUID                  = 311 ; int setresuid(uid_t ruid, uid_t euid, uid_t suid);
	SYS_SETRESGID                  = 312 ; int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
	;SYS_SIGNANOSLEEP              = 313 ; NOHIDE
	SYS_AIO_RETURN                 = 314 ; int aio_return(struct aiocb *aiocbp);
	SYS_AIO_SUSPEND                = 315 ; int aio_suspend(struct aiocb * const * aiocbp, int nent, const struct timespec *timeout);
	SYS_AIO_CANCEL                 = 316 ; int aio_cancel(int fd, struct aiocb *aiocbp);
	SYS_AIO_ERROR                  = 317 ; int aio_error(struct aiocb *aiocbp);
	SYS_AIO_READ                   = 318 ; int aio_read(struct aiocb *aiocbp);
	SYS_AIO_WRITE                  = 319 ; int aio_write(struct aiocb *aiocbp);
	SYS_LIO_LISTIO                 = 320 ; int lio_listio(int mode, struct aiocb * const *acb_list, int nent, struct sigevent *sig);
	SYS_YIELD                      = 321 ; int yield(void);
	SYS_THR_SLEEP                  = 322 ; int thr_sleep(const struct timespec *timeout);
	SYS_THR_WAKEUP                 = 323 ; int thr_wakeup(pid_t pid);
	SYS_MLOCKALL                   = 324 ; int mlockall(int how);
	SYS_MUNLOCKALL                 = 325 ; int munlockall(void);
	SYS___GETCWD                   = 326 ; int __getcwd(u_char *buf, u_int buflen);

	SYS_SCHED_SETPARAM             = 327 ; int sched_setparam (pid_t pid, const struct sched_param *param);
	SYS_SCHED_GETPARAM             = 328 ; int sched_getparam (pid_t pid, struct sched_param *param);

	SYS_SCHED_SETSCHEDULER         = 329 ; int sched_setscheduler (pid_t pid, int policy, const struct sched_param *param);
	SYS_SCHED_GETSCHEDULER         = 330 ; int sched_getscheduler (pid_t pid);

	SYS_SCHED_YIELD                = 331 ; int sched_yield (void);
	SYS_SCHED_GET_PRIORITY_MAX     = 332 ; int sched_get_priority_max (int policy);
	SYS_SCHED_GET_PRIORITY_MIN     = 333 ; int sched_get_priority_min (int policy);
	SYS_SCHED_RR_GET_INTERVAL      = 334 ; int sched_rr_get_interval (pid_t pid, struct timespec *interval);
	SYS_UTRACE                     = 335 ; int utrace(const void *addr, size_t len);
	;SYS_FREEBSD4_SENDFILE         = 336 ; NOHIDE
	SYS_KLDSYM                     = 337 ; int kldsym(int fileid, int cmd, void *data);
	SYS_JAIL                       = 338 ; int jail(struct jail *jail);
	;SYS_PIOCTL                    = 339 ; BSD
	SYS_SIGPROCMASK                = 340 ; int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
	SYS_SIGSUSPEND                 = 341 ; int sigsuspend(const sigset_t *sigmask);
	SYS_SIGACTION                  = 342 ; int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
	SYS_SIGPENDING                 = 343 ; int sigpending(sigset_t *set);
	SYS_SIGRETURN                  = 344 ; int sigreturn(ucontext_t *sigcntxp);
	SYS_SIGTIMEDWAIT               = 345 ; int sigtimedwait(const sigset_t *set,siginfo_t *info, const struct timespec *timeout);
	SYS_SIGWAITINFO                = 346 ; int sigwaitinfo(const sigset_t *set,siginfo_t *info);
	SYS___ACL_GET_FILE             = 347 ; int __acl_get_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_SET_FILE             = 348 ; int __acl_set_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_GET_FD               = 349 ; int __acl_get_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS___ACL_SET_FD               = 350 ; int __acl_set_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS___ACL_DELETE_FILE          = 351 ; int __acl_delete_file(const char *path, acl_type_t type);
	SYS___ACL_DELETE_FD            = 352 ; int __acl_delete_fd(int filedes, acl_type_t type);
	SYS___ACL_ACLCHECK_FILE        = 353 ; int __acl_aclcheck_file(const char *path, acl_type_t type, struct acl *aclp);
	SYS___ACL_ACLCHECK_FD          = 354 ; int __acl_aclcheck_fd(int filedes, acl_type_t type, struct acl *aclp);
	SYS_EXTATTRCTL                 = 355 ; int extattrctl(const char *path, int cmd, const char *attrname, char *arg);
	SYS_EXTATTR_SET_FILE           = 356 ; int extattr_set_file(const char *path, const char *attrname, struct iovec *iovp, unsigned iovcnt);
	SYS_EXTATTR_GET_FILE           = 357 ; int extattr_get_file(const char *path, const char *attrname, struct iovec *iovp, unsigned iovcnt);
	SYS_EXTATTR_DELETE_FILE        = 358 ; int extattr_delete_file(const char *path, const char *attrname);
	SYS_AIO_WAITCOMPLETE           = 359 ; int aio_waitcomplete(struct aiocb **aiocbp, struct timespec *timeout);
	SYS_GETRESUID                  = 360 ; int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
	SYS_GETRESGID                  = 361 ; int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
	SYS_KQUEUE                     = 362 ; int kqueue(void);
	SYS_KEVENT                     = 363 ; int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);
	SYS_SCTP_PEELOFF               = 364 ; int sctp_peeloff(int sd, caddr_t name );
; 365-392 used by FreeBSD-current
	;SYS_NOSYS                     = 365 ; NOHIDE
	;SYS_NOSYS                     = 366 ; NOHIDE
	;SYS_NOSYS                     = 367 ; NOHIDE
	;SYS_NOSYS                     = 368 ; NOHIDE
	;SYS_NOSYS                     = 369 ; NOHIDE
	;SYS_NOSYS                     = 370 ; NOHIDE
	;SYS_NOSYS                     = 371 ; NOHIDE
	;SYS_NOSYS                     = 372 ; NOHIDE
	;SYS_NOSYS                     = 373 ; NOHIDE
	;SYS_NOSYS                     = 374 ; NOHIDE
	;SYS_NOSYS                     = 375 ; NOHIDE
	;SYS_NOSYS                     = 376 ; NOHIDE
	;SYS_NOSYS                     = 377 ; NOHIDE
	;SYS_NOSYS                     = 378 ; NOHIDE
	;SYS_NOSYS                     = 379 ; NOHIDE
	;SYS_NOSYS                     = 380 ; NOHIDE
	;SYS_NOSYS                     = 381 ; NOHIDE
	;SYS_NOSYS                     = 382 ; NOHIDE
	;SYS_NOSYS                     = 383 ; NOHIDE
	;SYS_NOSYS                     = 384 ; NOHIDE
	;SYS_NOSYS                     = 385 ; NOHIDE
	;SYS_NOSYS                     = 386 ; NOHIDE
	;SYS_NOSYS                     = 387 ; NOHIDE
	;SYS_NOSYS                     = 388 ; NOHIDE
	;SYS_NOSYS                     = 389 ; NOHIDE
	;SYS_NOSYS                     = 390 ; NOHIDE
	SYS_LCHFLAGS                   = 391 ; int lchflags(char *path, int flags);
	SYS_UUIDGEN                    = 392 ; int uuidgen(struct uuid *store, int count);
	SYS_SENDFILE                   = 393 ; int sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags);
; 394-439 used by FreeBSD-current
	;SYS_NOSYS                     = 394 ; NOHIDE
	;SYS_NOSYS                     = 395 ; NOHIDE
	;SYS_NOSYS                     = 396 ; NOHIDE
	;SYS_NOSYS                     = 397 ; NOHIDE
	;SYS_NOSYS                     = 398 ; NOHIDE
	;SYS_NOSYS                     = 399 ; NOHIDE
	;SYS_NOSYS                     = 400 ; NOHIDE
	;SYS_NOSYS                     = 401 ; NOHIDE
	;SYS_NOSYS                     = 402 ; NOHIDE
	;SYS_NOSYS                     = 403 ; NOHIDE
	;SYS_NOSYS                     = 404 ; NOHIDE
	;SYS_NOSYS                     = 405 ; NOHIDE
	;SYS_NOSYS                     = 406 ; NOHIDE
	;SYS_NOSYS                     = 407 ; NOHIDE
	;SYS_NOSYS                     = 408 ; NOHIDE
	;SYS_NOSYS                     = 409 ; NOHIDE
	;SYS_NOSYS                     = 410 ; NOHIDE
	;SYS_NOSYS                     = 411 ; NOHIDE
	;SYS_NOSYS                     = 412 ; NOHIDE
	;SYS_NOSYS                     = 413 ; NOHIDE
	;SYS_NOSYS                     = 414 ; NOHIDE
	;SYS_NOSYS                     = 415 ; NOHIDE
	;SYS_NOSYS                     = 416 ; NOHIDE
	;SYS_NOSYS                     = 417 ; NOHIDE
	;SYS_NOSYS                     = 418 ; NOHIDE
	;SYS_NOSYS                     = 419 ; NOHIDE
	;SYS_NOSYS                     = 420 ; NOHIDE
	;SYS_NOSYS                     = 421 ; NOHIDE
	;SYS_NOSYS                     = 422 ; NOHIDE
	;SYS_NOSYS                     = 423 ; NOHIDE
	;SYS_NOSYS                     = 424 ; NOHIDE
	;SYS_NOSYS                     = 425 ; NOHIDE
	;SYS_NOSYS                     = 426 ; NOHIDE
	;SYS_NOSYS                     = 427 ; NOHIDE
	;SYS_NOSYS                     = 428 ; NOHIDE
	;SYS_NOSYS                     = 429 ; NOHIDE
	;SYS_NOSYS                     = 430 ; NOHIDE
	;SYS_NOSYS                     = 431 ; NOHIDE
	;SYS_NOSYS                     = 432 ; NOHIDE
	;SYS_NOSYS                     = 433 ; NOHIDE
	;SYS_NOSYS                     = 434 ; NOHIDE
	;SYS_NOSYS                     = 435 ; NOHIDE
	;SYS_NOSYS                     = 436 ; NOHIDE
	;SYS_NOSYS                     = 437 ; NOHIDE
	;SYS_NOSYS                     = 438 ; NOHIDE
	;SYS_NOSYS                     = 439 ; NOHIDE
; 440-449 reserved for FreeBSD-5.x growth
	;SYS_NOSYS                     = 440 ; NOHIDE
	;SYS_NOSYS                     = 441 ; NOHIDE
	;SYS_NOSYS                     = 442 ; NOHIDE
	;SYS_NOSYS                     = 443 ; NOHIDE
	;SYS_NOSYS                     = 444 ; NOHIDE
	;SYS_NOSYS                     = 445 ; NOHIDE
	;SYS_NOSYS                     = 446 ; NOHIDE
	;SYS_NOSYS                     = 447 ; NOHIDE
	;SYS_NOSYS                     = 448 ; NOHIDE
	;SYS_NOSYS                     = 449 ; NOHIDE
; 450 DragonFly system calls
	SYS_VARSYM_SET                 = 450 ; int varsym_set(int level, const char *name, const char *data);
	SYS_VARSYM_GET                 = 451 ; int varsym_get(int mask, const char *wild, char *buf, int bufsize);
	SYS_VARSYM_LIST                = 452 ; int varsym_list(int level, char *buf, int maxsize, int *marker);
	SYS_UPC_REGISTER               = 453 ; int upc_register(struct upcall *upc, void *ctxfunc, void *func, void *data);
	SYS_UPC_CONTROL                = 454 ; int upc_control(int cmd, int upcid, void *data);
	SYS_CAPS_SYS_SERVICE           = 455 ; int caps_sys_service(const char *name, uid_t uid, gid_t gid, int upcid, int flags);
	SYS_CAPS_SYS_CLIENT            = 456 ; int caps_sys_client(const char *name, uid_t uid, gid_t gid, int upcid, int flags);
	SYS_CAPS_SYS_CLOSE             = 457 ; int caps_sys_close(int portid);
	SYS_CAPS_SYS_PUT               = 458 ; off_t caps_sys_put(int portid, void *msg, int msgsize);
	SYS_CAPS_SYS_REPLY             = 459 ; int caps_sys_reply(int portid, void *msg, int msgsize, off_t msgcid);
	SYS_CAPS_SYS_GET               = 460 ; int caps_sys_get(int portid, void *msg, int maxsize, struct caps_msgid *msgid, struct caps_cred *ccr);
	SYS_CAPS_SYS_WAIT              = 461 ; int caps_sys_wait(int portid, void *msg, int maxsize, struct caps_msgid *msgid, struct caps_cred *ccr);
	SYS_CAPS_SYS_ABORT             = 462 ; int caps_sys_abort(int portid, off_t msgcid, int flags);
	SYS_CAPS_SYS_GETGEN            = 463 ; off_t caps_sys_getgen(int portid);
	SYS_CAPS_SYS_SETGEN            = 464 ; int caps_sys_setgen(int portid, off_t gen);
	SYS_EXEC_SYS_REGISTER          = 465 ; int exec_sys_register(void *entry);
	SYS_EXEC_SYS_UNREGISTER        = 466 ; int exec_sys_unregister(int id);
	SYS_CHECKPOINT                 = 467 ; int sys_checkpoint(int type, int fd, pid_t pid, int retval);
	SYS_MOUNTCTL                   = 468 ; int mountctl(const char *path, int op, int fd, const void *ctl, int ctllen, void *buf, int buflen);
	SYS_UMTX_SLEEP                 = 469 ; int umtx_sleep(volatile const int *ptr, int value, int timeout);
	SYS_UMTX_WAKEUP                = 470 ; int umtx_wakeup(volatile const int *ptr, int count);
	SYS_JAIL_ATTACH                = 471 ; int jail_attach(int jid);
	SYS_SET_TLS_AREA               = 472 ; int set_tls_area(int which, struct tls_info *info, size_t infosize);
	SYS_GET_TLS_AREA               = 473 ; int get_tls_area(int which, struct tls_info *info, size_t infosize);
	SYS_CLOSEFROM                  = 474 ; int closefrom(int fd);
	SYS_STAT                       = 475 ; int stat(const char *path, struct stat *ub);
	SYS_FSTAT                      = 476 ; int fstat(int fd, struct stat *sb);
	SYS_LSTAT                      = 477 ; int lstat(const char *path, struct stat *ub);
	SYS_FHSTAT                     = 478 ; int fhstat(const struct fhandle *u_fhp, struct stat *sb);
	SYS_GETDIRENTRIES              = 479 ; int getdirentries(int fd, char *buf, u_int count, long *basep);
	SYS_GETDENTS                   = 480 ; int getdents(int fd, char *buf, size_t count);
	SYS_USCHED_SET                 = 481 ; int usched_set(pid_t pid, int cmd, void *data, int bytes);
	SYS_EXTACCEPT                  = 482 ; int extaccept(int s, int flags, caddr_t name, int *anamelen);
	SYS_EXTCONNECT                 = 483 ; int extconnect(int s, int flags, caddr_t name, int namelen);
	SYS_SYSLINK                    = 484 ; int syslink(int cmd, struct syslink_info *info, size_t bytes);
	SYS_MCONTROL                   = 485 ; int mcontrol(void *addr, size_t len, int behav, off_t value);
	SYS_VMSPACE_CREATE             = 486 ; int vmspace_create(void *id, int type, void *data);
	SYS_VMSPACE_DESTROY            = 487 ; int vmspace_destroy(void *id);
	SYS_VMSPACE_CTL                = 488 ; int vmspace_ctl(void *id, int cmd, struct trapframe *tframe, struct vextframe *vframe);
	SYS_VMSPACE_MMAP               = 489 ; int vmspace_mmap(void *id, void *addr, size_t len, int prot, int flags, int fd, off_t offset);
	SYS_VMSPACE_MUNMAP             = 490 ; int vmspace_munmap(void *id, void *addr, size_t len);
	SYS_VMSPACE_MCONTROL           = 491 ; int vmspace_mcontrol(void *id, void *addr, size_t len, int behav, off_t value);
	SYS_VMSPACE_PREAD              = 492 ; ssize_t vmspace_pread(void *id, void *buf, size_t nbyte, int flags, off_t offset);
	SYS_VMSPACE_PWRITE             = 493 ; ssize_t vmspace_pwrite(void *id, const void *buf, size_t nbyte, int flags, off_t offset);
	SYS_EXTEXIT                    = 494 ; void extexit(int how, int status, void *addr);
	SYS_LWP_CREATE                 = 495 ; int lwp_create(struct lwp_params *params);
	SYS_LWP_GETTID                 = 496 ; lwpid_t lwp_gettid(void);
	SYS_LWP_KILL                   = 497 ; int lwp_kill(pid_t pid, lwpid_t tid, int signum);
	SYS_LWP_RTPRIO                 = 498 ; int lwp_rtprio(int function, pid_t pid, lwpid_t tid, struct rtprio *rtp);
	SYS_PSELECT                    = 499 ; int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *sigmask);
	SYS_STATVFS                    = 500 ; int statvfs(const char *path, struct statvfs *buf);
	SYS_FSTATVFS                   = 501 ; int fstatvfs(int fd, struct statvfs *buf);
	SYS_FHSTATVFS                  = 502 ; int fhstatvfs(const struct fhandle *u_fhp, struct statvfs *buf);
	SYS_GETVFSSTAT                 = 503 ; int getvfsstat(struct statfs *buf, struct statvfs *vbuf, long vbufsize, int flags);


;==============================================
; Converted with FreeBSD_syscalls4fasm.pl v1.0.5
; http://aldis.git.bsdroot.lv/asm4BSD/

; vim: set ts=8 sw=8 syn=fasm:
